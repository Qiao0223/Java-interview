# 1. MAC地址的作用

MAC 地址（媒体访问控制地址）是网络中设备的唯一标识符，主要用于局域网内的设备识别与通信。每个网络设备（如网卡、路由器等）都由制造商分配了一个独一无二的 MAC 地址。它用于标识设备之间的通信，确保数据传输到正确的设备。
### 主要作用：

1. **设备唯一标识**：确保每个设备在网络中有一个唯一的身份。
2. **局域网通信**：在同一局域网内，通过 MAC 地址来确保数据包准确发送给目标设备。
3. **ARP 协议**：用于将 IP 地址映射到 MAC 地址，确保设备间正确通信。
4. **网络安全**：通过 MAC 地址过滤来限制或允许特定设备访问网络。

MAC 地址通常由六个字节组成，前 3 字节标识制造商，后 3 字节为设备的唯一标识符。它是数据链路层的地址，仅在局域网内有效。

# 2. URL的组成

URL（Uniform Resource Locator，统一资源定位符）是用来定位互联网上资源的地址。它包含了不同的部分，每个部分都有特定的作用。一个典型的 URL 结构如下：
### URL的组成部分：

1. **协议（Scheme）**：
	- 表示使用的网络协议，例如 `http`、`https`、`ftp` 等。
2. **主机名（Hostname）**：
	- 指定资源所在的服务器地址，通常是域名或 IP 地址。
3. **端口（Port， 可选）**：
	- 指定服务器上的端口号，用于区分不同的服务。常见的端口号：80（HTTP）、443
4. **路径（Path）**：
	- 指定服务器上的具体资源路径，类似文件系统的路径。
5. **查询参数（Query， 可选）**：
	- 以 `?` 开始，用于传递参数信息。多个参数之间用 `&` 分隔。
6. **片段（Fragment， 可选）**：
	- 以 `#` 开始，用于指定页面中的某个部分（如锚点）。
### 示例 URL 分析：

`https://www.example.com:443/path/to/resource?id=123#section2`

- **协议**：`https`
- **主机名**：`www.example.com`
- **端口**：`443` (https 默认为 443)
- **路径**：`/path/to/resource`
- **查询参数**：`?id=123`
- **片段**：`#section2`
这些部分共同作用，帮助浏览器或应用程序准确定位和访问互联网上的资源。

# 3. HTTP请求的组成以及常见方法

**HTTP**（超文本传输协议）是一种应用层协议，用于客户端（如浏览器）和服务器之间的通信。HTTP 请求和响应由多个部分组成，这些部分包含了关于请求或响应的信息。

### **HTTP 请求的组成部分**

一个标准的 **HTTP 请求** 一般包含以下几个部分：

1. **请求行（Request Line）**：
    - **方法（Method）**：请求的类型（如 `GET`、`POST`、`PUT`、`DELETE`）。
    - **URL（Uniform Resource Locator）**：目标资源的地址。
    - **HTTP 版本（HTTP Version）**：客户端请求使用的 HTTP 版本，如 `HTTP/1.1` 或 `HTTP/2`。
2. **请求头（Request Headers）**：
    - 包含请求的额外信息，如浏览器类型、接受的数据类型、Cookie 信息等。
3. **请求体（Request Body）**（可选）：
    - 在某些 HTTP 方法（如 `POST` 和 `PUT`）中，可能包含发送的数据，例如表单提交的数据。

---
### **HTTP 响应的组成部分**

一个标准的 **HTTP 响应** 包括以下几个部分：
1. **状态行（Status Line）**：
    - **HTTP 版本（HTTP Version）**：响应所使用的 HTTP 版本。
    - **状态码（Status Code）**：表示响应的状态（如 `200` 表示成功，`404` 表示找不到资源）。
    - **状态消息（Status Message）**：对状态码的简单描述。
2. **响应头（Response Headers）**：
    - 包含响应的额外信息，如内容类型、服务器类型、缓存策略等
3. **响应体（Response Body）**：
    - 包含实际的响应内容，如 HTML 页面、JSON 数据、图片等。

---
### **HTTP 请求的常见方法**

1. **GET**：请求指定的资源。常用于获取数据，不修改数据。
2. **POST**：提交数据给服务器，通常用于表单提交。
3. **PUT**：更新指定的资源。
4. **DELETE**：删除指定的资源。
5. **PATCH**：部分更新指定的资源。
6. **HEAD**：请求与 `GET` 方法相同的响应，只是服务器不返回响应体。

# 4. HTTP与HTTPS的区别

**HTTP**（超文本传输协议）和 **HTTPS**（安全超文本传输协议）都是用于在客户端（如浏览器）和服务器之间传输数据的协议，但它们在数据传输的安全性上存在显著差异。下面是它们的主要区别：

### 1. **安全性**

- **HTTP**：数据以明文形式传输，容易被窃听和篡改，不适合处理敏感信息（如密码、信用卡号等）。
- **HTTPS**：通过 SSL/TLS 加密协议对数据进行加密传输，确保数据在传输过程中不被窃听或篡改，提供更高的安全性。

### 2. **端口号**

- **HTTP**：默认使用 **80** 端口。
- **HTTPS**：默认使用 **443** 端口。

### 3. **协议层**

- **HTTP**：是一个无状态的协议，传输的数据是明文的，且没有内建的加密机制。
- **HTTPS**：在 HTTP 协议基础上加上了 SSL/TLS 协议（安全套接层/传输层安全协议），通过加密通道传输数据，确保通信的安全性。

### 4. **性能**

- **HTTP**：由于没有加密过程，相对来说性能较好，传输速度较快。
- **HTTPS**：加密和解密过程会占用一定的计算资源，可能导致性能相较于 HTTP 略有降低，但现代硬件和优化技术已经使其性能差异不再显著。

### 5. **验证**

- **HTTP**：没有机制来验证服务器的身份，容易受到中间人攻击（MITM）。
- **HTTPS**：使用 SSL/TLS 证书来验证服务器身份，防止中间人攻击，确保客户端与正确的服务器通信。

### 6. **证书**

- **HTTP**：不需要证书。
- **HTTPS**：需要由受信任的证书颁发机构（CA）颁发的 SSL/TLS 证书，服务器和浏览器之间会进行证书验证。

### 7. **URL 格式**

- **HTTP**：URL 以 `http://` 开头。
- **HTTPS**：URL 以 `https://` 开头。

### 总结

- **HTTP** 适用于不涉及敏感数据的通信，速度较快，但缺乏安全性。
- **HTTPS** 适用于需要保证数据安全的场合（如银行网站、电子商务网站等），尽管它在性能上可能稍微有所降低，但提供了加密保护和身份验证，防止数据泄露和篡改。

# 5. TLS协议过程

**TLS**（Transport Layer Security，传输层安全性协议）是 **SSL**（Secure Sockets Layer）的继承者，用于保护网络通信的安全性，确保数据的保密性、完整性和认证。TLS协议主要用于HTTPS、邮件传输、VPN等多种通信场景中。TLS协议通过加密和身份验证来确保通信的安全。

![[Pasted image 20250304194100.png]]
### **TLS协议的工作过程**

TLS协议的工作过程可以分为两个主要阶段：

1. **握手阶段（Handshake）**
2. **数据传输阶段（Record）**

#### **1. 握手阶段（Handshake Phase）**

握手阶段是TLS通信的初步过程，确保双方的身份验证、加密算法选择，并生成会话密钥。握手包括以下步骤：

1. **客户端Hello（ClientHello）**：
    - 客户端向服务器发送 `ClientHello` 消息，包含以下内容：
        - 支持的TLS版本（如TLS 1.2、TLS 1.3）
        - 支持的加密套件（Cipher Suites）
        - 支持的压缩方法
        - 客户端生成的随机数（用于后续的加密过程）
2. **服务器Hello（ServerHello）**：
    - 服务器回复 `ServerHello` 消息，包含以下内容：
        - 选定的TLS版本
        - 选定的加密套件
        - 选定的压缩方法
        - 服务器生成的随机数
        - 服务器的证书（包含公钥，用于后续加密通信）
3. **服务器证书（Server Certificate）**：
    - 服务器将自己的 SSL/TLS 证书发送给客户端，证书由受信任的证书颁发机构（CA）签发，客户端验证服务器的身份。
4. **密钥交换（Key Exchange）**：
    - **密钥交换算法**：根据加密套件的选择，双方使用不同的算法（如RSA、ECDHE、DH等）进行密钥交换。
        - 如果使用 **RSA**：客户端生成一个预主密钥，并使用服务器的公钥加密后发送给服务器。
        - 如果使用 **ECDHE** 或 **DH**：双方交换公钥并计算共享密钥，确保安全性和前向保密性。
5. **客户端密钥交换（Client Key Exchange）**：
    - 客户端发送 `ClientKeyExchange` 消息，携带用于后续加密的预主密钥或公钥信息。
6. **服务器Hello Done**：
    - 服务器发送 `ServerHelloDone` 消息，表示它已经完成了握手阶段。
7. **客户端完成（Finished）**：
    - 客户端通过计算并发送一个加密的哈希值（`Finished`），用于验证握手过程的完整性。
8. **服务器完成（Finished）**：
    - 服务器接收到客户端的 `Finished` 消息后，也会发送一个加密的 `Finished` 消息，表示服务器已完成握手。
    
    **此时，握手阶段完成，双方可以开始安全的加密通信。**

---

#### **2. 数据传输阶段（Record Phase）**

在完成握手后，双方已经生成了共享的会话密钥（称为对称密钥），此时进入数据传输阶段。TLS 协议通过以下步骤保证数据的安全传输：

9. **数据加密**：
    - 客户端和服务器使用共享的会话密钥对发送的数据进行对称加密（如使用 AES、ChaCha20 等对称加密算法）。
10. **数据完整性校验**：
    - 为了防止数据在传输过程中被篡改，TLS 使用消息认证码（MAC）进行完整性校验。每个加密的数据包都附带一个MAC，接收方会验证数据包是否被篡改。
11. **数据压缩（可选）**：
    - 在传输过程中，可以选择启用数据压缩以提高传输效率，但在TLS 1.3中，已取消了压缩的使用。
12. **安全数据传输**：
    - 客户端和服务器通过加密的通道交换加密数据。这些加密的消息是保密的，并且通过验证的完整性来保证数据没有被篡改。
13. **会话关闭**：
    - 一旦数据传输完成，双方会进行会话关闭的过程。客户端发送 `close_notify` 消息，服务器回复同样的消息，确保没有任何数据丢失。

---

### **TLS 握手过程的简化流程图**

14. **ClientHello**
    - 客户端发送支持的加密套件、版本等信息。
15. **ServerHello + Server Certificate**
    - 服务器选择加密套件并发送其证书。
16. **密钥交换**
    - 双方交换密钥信息（如通过RSA、Diffie-Hellman等）。
17. **ClientKeyExchange + Finished**
    - 客户端发送加密的预主密钥并验证握手过程的完整性。
18. **Server Finished**
    - 服务器验证客户端的 `Finished` 并发送自己的 `Finished`。
19. **数据传输**（加密、完整性验证）
---

### 总结

- **握手阶段**确保了安全的通信环境，通过交换密钥、身份验证和加密套件选择建立加密通道。
- **数据传输阶段**使用对称加密进行安全的数据传输，并确保数据完整性。
- TLS通过使用加密和认证技术，确保通信过程中的数据不被窃听、篡改或伪造。

# 6. TCP 和 UDP 的区别是什么

TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）是两种不同的传输层协议，主要用于网络通信。它们的核心区别在于**可靠性**、**连接方式**和**传输效率**

![[Pasted image 20250305151130.png]]

**简单来说：**
- **TCP** 适用于需要**数据完整性和可靠性**的应用，如网页、文件传输、邮件等。
- **UDP** 适用于需要**速度和低延迟**，但可以容忍部分丢包的应用，如直播、游戏、DNS 查询等。

# 7. 为什么延迟低的场景使用 UDP？UDP 为什么性能会比 TCP 更好

在**低延迟场景**（如实时音视频、在线游戏、直播等）通常选择 **UDP** 而不是 **TCP**，主要原因在于 UDP **无连接、无状态、无确认机制**，因此在数据传输的**时延和性能**上比 TCP **更快**。以下是具体原因：
### **1. UDP 为什么延迟低？**

#### **① 无连接，不需要建立握手**

- **UDP 直接发送数据**，不需要像 TCP 那样进行**三次握手**来建立连接，避免了额外的时间开销。
- **TCP 需要三次握手**（约 1~2 个 RTT，往返时间），这在高延迟或丢包率高的网络环境下会进一步增加启动延迟。
- **UDP 可以立即发送数据**，非常适合**实时性要求高**的应用，如视频通话、游戏数据包等。

#### **② 无状态，服务器不维护连接**

- UDP 服务器不需要维护客户端的连接状态，每个数据包都是独立的，因此处理速度快，适用于**高并发**场景。
- TCP 服务器必须维护每个连接的状态，包括序列号、窗口大小、缓存等，**消耗大量内存**，连接数过多时会影响性能。

#### **③ 无流量控制，不会被 TCP 拥塞控制阻塞**

- **TCP 有流量控制**，如果网络出现拥塞，TCP 会降低发送速率，导致数据延迟。
- **UDP 没有流量控制**，即使网络拥塞，数据仍然会尽可能快速地发送出去，不会等待确认，避免了**Nagle 算法**带来的发送延迟。

#### **④ 无确认机制，避免了重传导致的额外延迟**

- TCP 通过**ACK 确认**确保数据可靠传输，但这需要额外的 RTT（往返时间）。
- 如果数据丢失，**TCP 需要重传**，进一步增加延迟。
- UDP **不等待确认**，即使数据丢失，也不会影响整体通信。例如，在视频直播或语音通话中，**丢失一帧数据不会影响播放**，但 TCP 的重传可能导致画面卡顿或音频延迟。

#### **⑤ 数据包顺序问题**

- **TCP 需要保证数据按顺序到达**，如果数据包乱序，TCP 需要缓存乱序数据，等待缺失的包到达后再处理，**导致额外的延迟**。
- **UDP 不关心顺序**，收到哪个包就处理哪个包，适用于**实时应用**（如游戏、直播、VoIP），即使数据丢失，用户也不会感受到明显影响。
### **2. UDP 为什么性能比 TCP 更好？**

#### **① 头部开销小，减少传输时间**

|**协议**|**TCP 头部**|**UDP 头部**|
|---|---|---|
|**大小**|**20~60 字节**|**8 字节**|

- UDP 头部 **仅 8 字节**，而 TCP 头部 **至少 20 字节**，在大规模数据传输时，UDP 具有更小的网络开销，减少了带宽占用，提高了传输速度。

#### **② 处理速度快，适合高并发**

- TCP 需要维护 **连接状态、窗口大小、重传队列、流量控制、拥塞控制**，CPU 负担大。
- UDP **不维护连接状态**，适用于**高并发**服务器，比如**DNS 服务器**可以每秒处理**数百万请求**。

#### **③ 没有握手、重传，减少 CPU 计算和网络开销**

- **TCP 需要维护大量状态信息**（如确认号、窗口大小、重传队列等）。
- **UDP 只发送数据**，不关心是否成功到达，**计算量更少，CPU 负担更低**。
### **3. 总结**

- **UDP 的低延迟优势** 来自于：
    
    - **无需握手**（减少 RTT）
    - **无连接、无状态**（服务器处理快，适合高并发）
    - **无流量控制**（避免 TCP 拥塞控制带来的延迟）
    - **无重传**（防止重传导致的额外等待时间）
    - **小数据包头**（减少传输开销）
- **UDP 的高性能优势**：
    
    - 处理速度快，服务器负担低，适用于**高并发场景**（如 DNS、视频直播、游戏）。
    - 头部小，带宽开销低，适用于**实时应用**（如 IoT、VoIP）。

# 8. Cookie vs Session 的区别

**Cookie 和 Session 都用于在 Web 应用中存储用户会话信息**，但它们的**存储方式、作用范围、安全性**等有所不同。

---

## **1️⃣ 核心区别对比**

|**对比项**|**Cookie**|**Session**|
|---|---|---|
|**存储位置**|**浏览器端**（客户端）|**服务器端**|
|**数据大小**|**最大 4KB**|**受服务器内存限制**|
|**安全性**|**低**（数据存储在客户端，可能被篡改）|**高**（数据存储在服务器）|
|**生命周期**|**默认浏览器关闭即失效**，可手动设置过期时间|**默认 Session 关闭即失效**，可设置超时时间|
|**跨域支持**|**支持**（同一域名下可访问）|**不支持跨域**（基于服务器存储）|
|**存储方式**|以 **键值对（key=value）** 存储字符串|**存储对象，可存放更多数据**|
|**性能影响**|**占用客户端资源**，不影响服务器|**占用服务器内存**，大量 Session 可能影响性能|
|**适用场景**|**存储用户偏好、保持登录状态、广告投放**|**存储用户会话信息、购物车、身份验证**|

---

## **2️⃣ 详细解析**

### **✅ Cookie**

- **存储在客户端**（浏览器），随请求发送到服务器。
- **适用于跨请求存储小数据**（如用户 ID、Token）。
- **易被篡改或窃取**，敏感数据需要加密。

📌 **适用场景**

- 记住用户登录状态（如 `remember me`）。
- 统计用户行为（如 Google Analytics）。
- **广告投放**（存储用户兴趣标签）。

---

### **✅ Session**

- **存储在服务器**，客户端只存 **Session ID（`JSESSIONID`）**。
- **数据不会暴露给客户端**，更安全。
- **适用于存储用户会话数据**（如购物车、权限信息）。

📌 **适用场景**

- **用户身份认证**（存储用户 ID）。
- **购物车**（存储选购商品）。
- **网站个性化设置**（存储用户配置）。

---

## **3️⃣ Cookie 和 Session 配合使用**

- **Cookie 存储 `SessionID`，Session 存储用户数据**。
- **服务器可通过 `SessionID` 识别用户并获取数据**。

📌 **示例**

1. **用户登录后，服务器生成 `Session`，存储用户信息**。
2. **服务器返回 `Set-Cookie: JSESSIONID=abc123; HttpOnly`，让浏览器保存**。
3. **浏览器每次请求时，自动带上 `JSESSIONID`，服务器从 Session 读取用户信息**。

---

## **4️⃣ 选择 Cookie 还是 Session？**

✅ **用 Cookie**

- 存储小型数据（如 `theme=dark`）。
- **跨会话存储**（如记住用户登录状态）。
- **服务器无状态**（如 REST API 认证 Token）。

✅ **用 Session**

- **存储用户会话数据**（如购物车、用户信息）。
- **更安全**（不暴露敏感数据给客户端）。
- **短时间存储交互数据**（如 Web 端身份认证）。

🚀 **最佳实践**：**结合使用 Cookie（存 SessionID）+ Session（存用户数据），兼顾安全性和性能！** 🔥

# 9. TCP 三次握手后，服务端网络延迟时客户端如何保证传输可靠性？

在 **TCP 三次握手** 成功后，客户端和服务端之间建立了**可靠的双向连接**，但如果**服务端网络出现延迟**，TCP 仍然可以通过多种机制保证数据传输的可靠性。

---

## **1️⃣ TCP 如何保证传输的可靠性？**

### **📌 1. 可靠传输机制**

TCP 通过 **超时重传、流量控制、拥塞控制等机制**，确保数据可靠送达。

| **机制**                   | **作用**                    |
| ------------------------ | ------------------------- |
| **ACK 确认机制**             | 发送方必须收到 ACK 确认，否则会重传数据    |
| **超时重传机制（RTO）**          | 如果一定时间内未收到 ACK，TCP 重新发送数据 |
| **流量控制（Sliding Window）** | 服务器接收能力下降时，调整发送窗口，避免丢包    |
| **拥塞控制（慢启动、拥塞避免）**       | 防止网络拥塞导致数据丢失              |
| **乱序重组**                 | 数据乱序到达时，TCP 按序重组数据        |

---

## **2️⃣ 服务端网络延迟对 TCP 影响**

如果 **服务端网络出现延迟**，可能导致：

1. **ACK 确认变慢** → 客户端等待 ACK 时间变长，可能触发 **超时重传**。
2. **TCP 滑动窗口缩小** → 服务端响应慢，导致 TCP 发送窗口减小，客户端发送速度下降。
3. **网络拥塞** → 可能触发 TCP **拥塞控制**，进一步降低数据传输速率。

---

## **3️⃣ 客户端如何应对服务端网络延迟？**

### **📌 1. 超时重传机制**

- **TCP 设定 RTO（重传超时）**，如果在**一定时间内未收到 ACK**，客户端会**自动重传数据**。
- **动态调整 RTO**，TCP 会根据往返时间（RTT）调整超时时间，避免过早或过晚重传。

### **📌 2. 滑动窗口 & 流量控制**

- **如果服务端延迟导致 ACK 变慢**，TCP 可能减少窗口大小，客户端会**降低发送速率**，避免丢包。
- **当服务端恢复正常**，TCP 发送窗口会**逐步增大，恢复正常传输速度**。

### **📌 3. 拥塞控制**

- TCP **检测到延迟增加**（RTT 变大），可能会进入 **拥塞避免阶段**，减少数据发送速率，**防止丢包**。
- **慢启动**：如果服务端恢复，TCP 会**逐步提高发送速率**，避免网络抖动。

### **📌 4. KeepAlive 保持连接**

- 如果网络延迟过久，客户端可能会**发送 KeepAlive 探测包**，确保连接仍然有效，避免因长时间未收到数据而断开。

### **📌 5. 应用层重试**

- 如果 TCP **多次重传仍未成功**，应用层（如 HTTP、RPC）可能会**触发重试机制**，尝试重新发送请求。

---

## **4️⃣ 结论**

|**服务端网络延迟问题**|**TCP 保障方式**|
|---|---|
|**ACK 变慢**|超时重传（RTO）|
|**流量控制触发**|滑动窗口调整|
|**网络拥塞**|拥塞控制（慢启动）|
|**长时间无响应**|KeepAlive 探测|
|**重传失败**|应用层重试（如 HTTP 5xx 自动重试）|

🚀 **TCP 通过超时重传、流量控制、拥塞控制等机制，即使服务端网络延迟，也能保证数据可靠传输！🔥**