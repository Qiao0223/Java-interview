# 1. 进程调度算法

进程调度算法决定了**CPU 如何在多个进程之间进行切换和分配时间**，主要目标是 **提高 CPU 利用率、减少进程等待时间、保证系统公平性**。

---

## **1️⃣ 进程调度的基本概念**

### **📌 进程调度的三种方式**

1. **非抢占式调度（Non-Preemptive）**
    
    - **CPU 一旦分配给某个进程，进程必须主动释放 CPU**（如 I/O 阻塞、终止）。
    - **适用于批处理系统**，如 **先来先服务（FCFS）、短作业优先（SJF）**。
2. **抢占式调度（Preemptive）**
    
    - **CPU 可随时从正在运行的进程切换到其他进程**。
    - **适用于多任务和实时系统**，如 **时间片轮转（RR）、优先级调度、抢占式 SJF**。
3. **混合调度**
    
    - 结合 **抢占式和非抢占式**，适用于不同场景（如 Linux 调度）。

---

## **2️⃣ 主要进程调度算法**

|**算法**|**抢占性**|**优先级**|**适用场景**|
|---|---|---|---|
|**先来先服务（FCFS）**|❌ 非抢占式|无|批处理系统|
|**短作业优先（SJF）**|✅ 可抢占|低|适用于 CPU 计算密集型任务|
|**最高优先级调度（Priority）**|✅ 可抢占|有|适用于需要优先处理的任务（如实时系统）|
|**时间片轮转（RR）**|✅ 可抢占|无|适用于交互式系统|
|**多级反馈队列（MLFQ）**|✅ 可抢占|有|适用于多任务操作系统|
|**最短剩余时间优先（SRTF）**|✅ 可抢占|低|适用于需要快速响应的小任务|

---

## **3️⃣ 进程调度算法详解**

### **📌 1. 先来先服务（FCFS）**

- **非抢占式调度**，按照进程到达顺序执行。
- **优点**：简单、公平，无饥饿现象。
- **缺点**：可能导致**短任务等待长任务（“短任务饥饿”）**。

---

### **📌 2. 短作业优先（SJF）**

- **按进程运行时间长短排序，短进程优先执行**。
    
- **非抢占式 SJF**：
    
    - 进程一旦获得 CPU，不会被抢占。
- **抢占式 SJF（最短剩余时间优先，SRTF）**：
    
    - 如果有更短的进程到来，会抢占当前进程。
- **优点**：最小化平均等待时间。
    
- **缺点**：长作业可能一直等待（“长任务饥饿”）。
    

---

### **📌 3. 最高优先级调度（Priority）**

- **每个进程分配一个优先级，优先级高的进程先执行**。
    
- **两种方式**：
    
    - **非抢占式**：高优先级进程执行完毕后，低优先级进程才运行。
    - **抢占式**：如果有更高优先级进程到来，会抢占当前进程。
- **缺点**：
    
    - **可能导致“低优先级进程饥饿”**（解决方案：**动态优先级提升**）。
    - **实时系统适用，如任务调度、数据库请求处理**。

---

### **📌 4. 时间片轮转（Round Robin，RR）**

- **抢占式调度，每个进程按时间片（如 100ms）轮流执行**。
    
- **时间片用完后，进程进入就绪队列，等待下一轮调度**。
    
- **优点**：
    
    - 适用于 **交互式系统**（响应快）。
    - 确保所有进程 **公平执行**，不会饿死。
- **缺点**：
    
    - 时间片太小 → **进程频繁切换，系统开销高（上下文切换）**。
    - 时间片太大 → **退化成 FCFS（长任务占用 CPU）**。

---

### **📌 5. 多级反馈队列（MLFQ）**

- **多个优先级队列，进程根据执行情况在队列间动态调整**。
    
- **新进程进入高优先级队列，运行后优先级逐步降低**。
    
- **长时间等待的进程可以动态提升优先级，避免“饥饿”**。
    
- **适用于现代操作系统（如 Linux 调度器 CFS）**：
    
    - **短任务先执行**，提高响应速度。
    - **长任务逐步降低优先级，防止短任务饥饿**。

---

## **4️⃣ 进程调度算法的比较**

|**算法**|**优点**|**缺点**|**适用场景**|
|---|---|---|---|
|**FCFS**|简单、公平|**长任务影响短任务**|**批处理系统**|
|**SJF**|**最小等待时间**|**长任务可能一直等待**|**CPU 密集型任务**|
|**Priority**|**高优先级任务先执行**|**低优先级任务可能饿死**|**实时系统**|
|**RR**|**响应时间快**|**可能导致高频切换（高开销）**|**交互式系统**|
|**MLFQ**|**综合优点，适应性强**|**复杂度高**|**通用操作系统**|

---

## **5️⃣ 现代操作系统使用的调度算法**

|**操作系统**|**使用的调度算法**|
|---|---|
|**Windows**|**基于优先级的抢占式调度**|
|**Linux**|**CFS（完全公平调度），基于 MLFQ**|
|**macOS**|**优先级 + 时间片轮转**|
|**Android**|**Linux CFS + 实时调度**|

---

## **6️⃣ 结论**

- **批处理系统（无交互）适合 FCFS、SJF**。
- **交互式系统（响应时间重要）适合 RR、MLFQ**。
- **实时系统适合 优先级调度（Priority Scheduling）**。
- **现代操作系统使用 MLFQ + CFS（Linux 完全公平调度器）**。

# 2. 哈希算法

哈希算法是一种 **散列函数**，它能将 **任意长度的数据映射为固定长度的值**。哈希算法广泛用于 **加密、数据检索、负载均衡、数据完整性**等领域。

---

## **1. 哈希算法的特性**

一个优秀的哈希算法应具备以下特性：

1. **不可逆性（Irreversibility）**
    - 不能从哈希值反推出原始数据（如 `SHA-256`）。
2. **冲突避免（Collision Resistant）**
    - **不同的输入** 产生 **不同的哈希值**（哈希碰撞概率极低）。
3. **均匀性（Uniformity）**
    - 哈希值在输出范围内 **均匀分布**，避免哈希表过载。
4. **高效计算（Efficiency）**
    - 计算速度快，适用于大规模数据处理。
5. **微小变化，输出大变化（Avalanche Effect）**
    - 输入改动一位，哈希值变化剧烈（如 `SHA-256` 的 **雪崩效应**）。

---

## **2. 常见哈希算法**

|算法|输出位数|主要用途|特点|
|---|---|---|---|
|**MD5**|128-bit|文件校验、密码存储（已不安全）|快速但易碰撞|
|**SHA-1**|160-bit|旧版 SSL、PGP、Git 版本管理|比 MD5 更安全，但已被破解|
|**SHA-256**|256-bit|区块链、密码学、数字签名|目前主流，安全性高|
|**SHA-512**|512-bit|密码存储、高安全性需求|适用于高强度加密|
|**CRC32**|32-bit|数据完整性检查（ZIP、RAR）|仅适用于校验，非安全哈希|
|**CityHash / MurmurHash**|32/64-bit|哈希索引、负载均衡|适用于高效哈希计算|
## **3. 哈希算法的应用**

### **(1) 数据完整性校验**

- **文件下载时，验证数据是否被篡改**
- 常用 `MD5/SHA-256` 比对文件哈希值

---

### **(2) 密码存储**

- **不要直接存储密码的哈希值**，使用 **加盐（Salt）+ 哈希**

---

### **(3) 哈希索引**

- **数据库索引（如 MongoDB）**
- **布隆过滤器**（防止缓存穿透）

---

### **(4) 负载均衡**

- **一致性哈希（Consistent Hashing）**
- 适用于 **分布式缓存（如 Redis Cluster）**

---

### **4. 哈希碰撞（Hash Collision）**

哈希碰撞发生时，**不同的输入得到相同的哈希值**，主要攻击方式：

- **生日攻击（Birthday Attack）**：通过数学原理快速找到碰撞值。
- **彩虹表（Rainbow Table）**：存储大量预计算哈希，破解密码。

**避免哈希碰撞的方法**

- 使用更长的哈希，如 **SHA-256**（比 MD5 更安全）
- **加盐（Salt）** 处理密码，避免预计算攻击

---

### **5. 总结**

|用途|适用算法|
|---|---|
|**文件完整性校验**|SHA-256, CRC32|
|**密码存储**|bcrypt, PBKDF2, Argon2|
|**哈希索引**|MurmurHash, CityHash|
|**区块链**|SHA-256|
|**负载均衡**|一致性哈希|

# 3. 排序算法

排序算法用于 **重新排列数组或列表**，以满足 **升序或降序** 的顺序。不同的排序算法在 **时间复杂度** 和 **空间复杂度** 上有所不同，选择合适的排序算法取决于数据规模、稳定性需求等。

---

## **1. 常见排序算法分类**

| **排序算法**                 | **时间复杂度（最坏/平均/最好）**            | **空间复杂度** | **是否稳定** | **适用场景**         |
| ------------------------ | ------------------------------ | --------- | -------- | ---------------- |
| **冒泡排序（Bubble Sort）**    | O(N²) / O(N²) / O(N)           | O(1)      | ✅ 是      | 小数据量，数据几乎有序      |
| **选择排序（Selection Sort）** | O(N²) / O(N²) / O(N²)          | O(1)      | ❌ 否      | 适用于少量数据          |
| **插入排序（Insertion Sort）** | O(N²) / O(N²) / O(N)           | O(1)      | ✅ 是      | 适用于小规模、基本有序数据    |
| **希尔排序（Shell Sort）**     | O(N²) / O(NlogN) / O(N)        | O(1)      | ❌ 否      | 改进插入排序，适用于中等数据规模 |
| **归并排序（Merge Sort）**     | O(NlogN) / O(NlogN) / O(NlogN) | O(N)      | ✅ 是      | 适用于大规模数据，稳定排序    |
| **快速排序（Quick Sort）**     | O(N²) / O(NlogN) / O(NlogN)    | O(logN)   | ❌ 否      | 适用于大规模数据，最常用     |
| **堆排序（Heap Sort）**       | O(NlogN) / O(NlogN) / O(NlogN) | O(1)      | ❌ 否      | 适用于优先队列          |
| **计数排序（Counting Sort）**  | O(N+K) / O(N+K) / O(N+K)       | O(K)      | ✅ 是      | 适用于数据范围小的整数排序    |
| **桶排序（Bucket Sort）**     | O(N+K) / O(N+K) / O(N+K)       | O(N+K)    | ✅ 是      | 适用于浮点数、均匀分布的数据   |
| **基数排序（Radix Sort）**     | O(N_K) / O(N_K) / O(N*K)       | O(N+K)    | ✅ 是      | 适用于整数、大数据量       |

---

## **2. 常见排序算法实现**

### **1. 冒泡排序（Bubble Sort）**

**思想：** 两两交换，较大元素不断上浮，最终有序。

✅ **稳定排序**，时间复杂度 O(N²)，适用于小规模数据。

---

### **2. 选择排序（Selection Sort）**

**思想：** 每次找到最小元素，放到已排序部分的后面。

❌ **不稳定排序**，时间复杂度 O(N²)，适用于少量数据。

---

### **3. 插入排序（Insertion Sort）**

**思想：** 逐步插入到合适位置，保证前 i 个元素有序。

✅ **稳定排序**，适用于小规模、近乎有序的数据。

---

### **4. 归并排序（Merge Sort）**

**思想：** 递归拆分数组，再合并两个有序数组。

✅ **稳定排序**，O(N log N)，适用于大规模数据。

---

### **5. 快速排序（Quick Sort）**

**思想：** 选择一个 `pivot`，小的放左边，大的放右边，递归排序。

❌ **不稳定排序**，O(N log N)，适用于大数据量。

---

### **6. 堆排序（Heap Sort）**

**思想：** 用最大堆找出最大值，每次放到数组末尾。

❌ **不稳定排序**，O(N log N)，适用于优先队列场景。

---

### **7. 计数排序（Counting Sort）**

**思想：** 统计每个元素出现次数，计算累加和，重排数组。

✅ **稳定排序**，O(N+K)，适用于范围小的整数排序。

---

### **8. 基数排序（Radix Sort）**

**思想：** 按位（个位、十位...）进行多轮计数排序。

✅ **稳定排序**，O(NK)，适用于大整数排序。

---

## **总结**

- **小数据量（≤1000）：插入排序、冒泡排序**
- **大数据量（≥1000）：快速排序、归并排序**
- **整数排序：计数排序、基数排序**
- **优先队列：堆排序**

# 4. 页表（Page Table）

**页表（Page Table）** 是操作系统 **虚拟内存管理** 机制中的一个关键数据结构。它用于 **维护虚拟地址（Virtual Address）到物理地址（Physical Address）的映射**，从而实现 **进程独立的虚拟地址空间**。

---

## **1. 为什么需要页表？**

在现代计算机系统中，**程序运行使用的是虚拟地址，而实际访问的内存是物理地址**。  
CPU 访问内存时，需要 **将虚拟地址转换为物理地址（地址转换）**，但：

1. **进程的虚拟地址是独立的，不直接对应物理内存**。
2. **不同进程可能使用相同的虚拟地址，但映射到不同的物理地址**。
3. **程序运行的代码和数据可能不连续存放在物理内存中**（碎片化问题）。
4. **进程的地址空间可能比物理内存大**，需要使用 **分页机制** 来按需加载内存。

因此，**页表用于维护虚拟地址到物理地址的映射**，帮助 CPU 进行地址转换。

---

## **2. 基本概念**

### **(1) 逻辑地址 vs 物理地址**

- **逻辑地址（虚拟地址，Virtual Address）**：
    - 进程访问的地址，由 CPU 生成。
    - 例如，程序中的 `ptr = 0x7FFDF000` 是逻辑地址。
- **物理地址（Physical Address）**：
    - 实际存储在 RAM（主存）中的地址。
    - 例如，0x7FFDF000 可能映射到 **RAM 的 0x1A3BC000**。

CPU 需要 **页表** 来转换逻辑地址到物理地址。

---

### **(2) 分页机制**

分页（Paging）是 **将内存划分为固定大小的块**：

- **页（Page）**：进程的虚拟内存以 **页大小**（如 4KB）划分。
- **页帧（Page Frame）**：物理内存也被划分成 **相同大小的页帧**。

**示例**
```
虚拟内存：
+------------+------------+------------+
| Page 0     | Page 1     | Page 2     | ...
+------------+------------+------------+

物理内存：
+------------+------------+------------+
| Frame 3    | Frame 7    | Frame 1    | ...
+------------+------------+------------+
```
假设**虚拟页 0** 被映射到 **物理页帧 3**，那么：

`虚拟地址 = 0x00003000  (Page 0) 物理地址 = 0x00303000  (Frame 3)`

页表存储的就是这个映射关系。

---

## **3. 页表的结构**

### **(1) 页表内容**

每个进程都有 **自己的页表**，存储虚拟页到物理页帧的映射：
```
+-------+-----------+
| 虚拟页 | 物理页帧  |
+-------+-----------+
| Page 0 | Frame 3  |
| Page 1 | Frame 7  |
| Page 2 | Frame 1  |
+-------+-----------+
```
每个 **页表项（Page Table Entry，PTE）** 通常包括：

|字段|作用|
|---|---|
|物理页帧号|指向物理内存中的页帧|
|P 位（Present）|是否在物理内存（否则发生缺页）|
|R/W 位|读/写权限|
|U/S 位|用户/系统权限|
|D 位|是否被修改（脏页）|
|A 位|访问位，是否被使用|

---

### **(2) 地址转换过程**

假设一个进程访问虚拟地址 **0x00403020**（16 进制表示），转换过程如下：

1. **拆分虚拟地址**
    `0x00403020 (虚拟地址) = 页号 0x00403（高位） + 偏移量 0x020（低位）`
2. **查找页表**
    - 访问 **页表**，找到 **虚拟页 0x00403** 对应的 **物理页帧**。
3. **计算物理地址**
    `物理页帧 = 0x001A7 物理地址 = 0x001A7 * 4KB + 0x020          = 0x1A7020`
4. **CPU 访问物理地址 0x1A7020**。

---

## **4. 多级页表（优化页表）**

**问题：** 直接存储 **整个页表会占用大量内存**，尤其是 64 位系统。

**解决方案：** 使用 **多级页表**，减少存储开销：

1. **一级页表** 存储二级页表地址
2. **二级页表** 存储物理页帧地址

**示例（两级页表）**
```
虚拟地址 0x00403020 解析：
- 一级页表索引：0x004
- 二级页表索引：0x03
- 偏移量：0x020
```
多级页表可以 **减少内存占用，但增加地址转换次数**。

---

## **5. 快速页表映射（TLB）**

**问题：** 每次访问内存都要查页表，太慢！

**解决方案：**

- CPU 里有 **TLB（Translation Lookaside Buffer）**，缓存**常用的页表项**。
- **TLB 命中**：直接得到物理地址。
- **TLB 未命中**：访问主存中的页表，然后加载到 TLB。

**示例**
```
TLB（缓存页表映射）：
+--------+-----------+
| 虚拟页 | 物理页帧 |
+--------+-----------+
| 0x00403 | 0x1A7    | ✅ TLB 命中
```
TLB 使**地址转换速度提高 10 倍以上**。

---

## **6. 页表的应用**

### **(1) 虚拟内存管理**

- **进程隔离**：每个进程有自己的页表，互不影响。
- **按需加载**：程序访问不到的页不占用物理内存（缺页中断）。
- **内存交换（Swap）**：不活跃页可以换出到硬盘，释放物理内存。

### **(2) 进程间通信（共享内存）**

- 两个进程的页表可以映射到相同的物理页，允许共享数据。

### **(3) 高效缓存管理（TLB）**

- 现代 CPU 依赖 TLB 进行页表加速，提高地址转换性能。

---

## **7. 结论**

|**特点**|**描述**|
|---|---|
|**作用**|维护虚拟地址到物理地址的映射|
|**分页机制**|将内存划分为**固定大小的页**，虚拟页映射到物理页帧|
|**地址转换**|通过**页表查询**实现虚拟地址到物理地址的转换|
|**优化方案**|**多级页表**（节省空间）、**TLB 缓存**（加速转换）|
|**缺页中断**|访问**不在内存的页**，触发**缺页中断**|