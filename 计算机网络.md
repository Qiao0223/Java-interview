# 1. MAC地址的作用

MAC 地址（媒体访问控制地址）是网络中设备的唯一标识符，主要用于局域网内的设备识别与通信。每个网络设备（如网卡、路由器等）都由制造商分配了一个独一无二的 MAC 地址。它用于标识设备之间的通信，确保数据传输到正确的设备。
### 主要作用：

1. **设备唯一标识**：确保每个设备在网络中有一个唯一的身份。
2. **局域网通信**：在同一局域网内，通过 MAC 地址来确保数据包准确发送给目标设备。
3. **ARP 协议**：用于将 IP 地址映射到 MAC 地址，确保设备间正确通信。
4. **网络安全**：通过 MAC 地址过滤来限制或允许特定设备访问网络。

MAC 地址通常由六个字节组成，前 3 字节标识制造商，后 3 字节为设备的唯一标识符。它是数据链路层的地址，仅在局域网内有效。

# 2. URL的组成

URL（Uniform Resource Locator，统一资源定位符）是用来定位互联网上资源的地址。它包含了不同的部分，每个部分都有特定的作用。一个典型的 URL 结构如下：
### URL的组成部分：

1. **协议（Scheme）**：
	- 表示使用的网络协议，例如 `http`、`https`、`ftp` 等。
2. **主机名（Hostname）**：
	- 指定资源所在的服务器地址，通常是域名或 IP 地址。
3. **端口（Port， 可选）**：
	- 指定服务器上的端口号，用于区分不同的服务。常见的端口号：80（HTTP）、443
4. **路径（Path）**：
	- 指定服务器上的具体资源路径，类似文件系统的路径。
5. **查询参数（Query， 可选）**：
	- 以 `?` 开始，用于传递参数信息。多个参数之间用 `&` 分隔。
6. **片段（Fragment， 可选）**：
	- 以 `#` 开始，用于指定页面中的某个部分（如锚点）。
### 示例 URL 分析：

`https://www.example.com:443/path/to/resource?id=123#section2`

- **协议**：`https`
- **主机名**：`www.example.com`
- **端口**：`443` (https 默认为 443)
- **路径**：`/path/to/resource`
- **查询参数**：`?id=123`
- **片段**：`#section2`
这些部分共同作用，帮助浏览器或应用程序准确定位和访问互联网上的资源。

# 3. HTTP请求的组成以及常见方法

**HTTP**（超文本传输协议）是一种应用层协议，用于客户端（如浏览器）和服务器之间的通信。HTTP 请求和响应由多个部分组成，这些部分包含了关于请求或响应的信息。

### **HTTP 请求的组成部分**

一个标准的 **HTTP 请求** 一般包含以下几个部分：

1. **请求行（Request Line）**：
    - **方法（Method）**：请求的类型（如 `GET`、`POST`、`PUT`、`DELETE`）。
    - **URL（Uniform Resource Locator）**：目标资源的地址。
    - **HTTP 版本（HTTP Version）**：客户端请求使用的 HTTP 版本，如 `HTTP/1.1` 或 `HTTP/2`。
2. **请求头（Request Headers）**：
    - 包含请求的额外信息，如浏览器类型、接受的数据类型、Cookie 信息等。
3. **请求体（Request Body）**（可选）：
    - 在某些 HTTP 方法（如 `POST` 和 `PUT`）中，可能包含发送的数据，例如表单提交的数据。

---
### **HTTP 响应的组成部分**

一个标准的 **HTTP 响应** 包括以下几个部分：
1. **状态行（Status Line）**：
    - **HTTP 版本（HTTP Version）**：响应所使用的 HTTP 版本。
    - **状态码（Status Code）**：表示响应的状态（如 `200` 表示成功，`404` 表示找不到资源）。
    - **状态消息（Status Message）**：对状态码的简单描述。
2. **响应头（Response Headers）**：
    - 包含响应的额外信息，如内容类型、服务器类型、缓存策略等
3. **响应体（Response Body）**：
    - 包含实际的响应内容，如 HTML 页面、JSON 数据、图片等。

---
### **HTTP 请求的常见方法**

1. **GET**：请求指定的资源。常用于获取数据，不修改数据。
2. **POST**：提交数据给服务器，通常用于表单提交。
3. **PUT**：更新指定的资源。
4. **DELETE**：删除指定的资源。
5. **PATCH**：部分更新指定的资源。
6. **HEAD**：请求与 `GET` 方法相同的响应，只是服务器不返回响应体。

# 4. HTTP与HTTPS的区别

**HTTP**（超文本传输协议）和 **HTTPS**（安全超文本传输协议）都是用于在客户端（如浏览器）和服务器之间传输数据的协议，但它们在数据传输的安全性上存在显著差异。下面是它们的主要区别：

### 1. **安全性**

- **HTTP**：数据以明文形式传输，容易被窃听和篡改，不适合处理敏感信息（如密码、信用卡号等）。
- **HTTPS**：通过 SSL/TLS 加密协议对数据进行加密传输，确保数据在传输过程中不被窃听或篡改，提供更高的安全性。

### 2. **端口号**

- **HTTP**：默认使用 **80** 端口。
- **HTTPS**：默认使用 **443** 端口。

### 3. **协议层**

- **HTTP**：是一个无状态的协议，传输的数据是明文的，且没有内建的加密机制。
- **HTTPS**：在 HTTP 协议基础上加上了 SSL/TLS 协议（安全套接层/传输层安全协议），通过加密通道传输数据，确保通信的安全性。

### 4. **性能**

- **HTTP**：由于没有加密过程，相对来说性能较好，传输速度较快。
- **HTTPS**：加密和解密过程会占用一定的计算资源，可能导致性能相较于 HTTP 略有降低，但现代硬件和优化技术已经使其性能差异不再显著。

### 5. **验证**

- **HTTP**：没有机制来验证服务器的身份，容易受到中间人攻击（MITM）。
- **HTTPS**：使用 SSL/TLS 证书来验证服务器身份，防止中间人攻击，确保客户端与正确的服务器通信。

### 6. **证书**

- **HTTP**：不需要证书。
- **HTTPS**：需要由受信任的证书颁发机构（CA）颁发的 SSL/TLS 证书，服务器和浏览器之间会进行证书验证。

### 7. **URL 格式**

- **HTTP**：URL 以 `http://` 开头。
- **HTTPS**：URL 以 `https://` 开头。

### 总结

- **HTTP** 适用于不涉及敏感数据的通信，速度较快，但缺乏安全性。
- **HTTPS** 适用于需要保证数据安全的场合（如银行网站、电子商务网站等），尽管它在性能上可能稍微有所降低，但提供了加密保护和身份验证，防止数据泄露和篡改。

# 5. TLS协议过程

**TLS**（Transport Layer Security，传输层安全性协议）是 **SSL**（Secure Sockets Layer）的继承者，用于保护网络通信的安全性，确保数据的保密性、完整性和认证。TLS协议主要用于HTTPS、邮件传输、VPN等多种通信场景中。TLS协议通过加密和身份验证来确保通信的安全。

![[Pasted image 20250304194100.png]]
### **TLS协议的工作过程**

TLS协议的工作过程可以分为两个主要阶段：

1. **握手阶段（Handshake）**
2. **数据传输阶段（Record）**

#### **1. 握手阶段（Handshake Phase）**

握手阶段是TLS通信的初步过程，确保双方的身份验证、加密算法选择，并生成会话密钥。握手包括以下步骤：

1. **客户端Hello（ClientHello）**：
    - 客户端向服务器发送 `ClientHello` 消息，包含以下内容：
        - 支持的TLS版本（如TLS 1.2、TLS 1.3）
        - 支持的加密套件（Cipher Suites）
        - 支持的压缩方法
        - 客户端生成的随机数（用于后续的加密过程）
2. **服务器Hello（ServerHello）**：
    - 服务器回复 `ServerHello` 消息，包含以下内容：
        - 选定的TLS版本
        - 选定的加密套件
        - 选定的压缩方法
        - 服务器生成的随机数
        - 服务器的证书（包含公钥，用于后续加密通信）
3. **服务器证书（Server Certificate）**：
    - 服务器将自己的 SSL/TLS 证书发送给客户端，证书由受信任的证书颁发机构（CA）签发，客户端验证服务器的身份。
4. **密钥交换（Key Exchange）**：
    - **密钥交换算法**：根据加密套件的选择，双方使用不同的算法（如RSA、ECDHE、DH等）进行密钥交换。
        - 如果使用 **RSA**：客户端生成一个预主密钥，并使用服务器的公钥加密后发送给服务器。
        - 如果使用 **ECDHE** 或 **DH**：双方交换公钥并计算共享密钥，确保安全性和前向保密性。
5. **客户端密钥交换（Client Key Exchange）**：
    - 客户端发送 `ClientKeyExchange` 消息，携带用于后续加密的预主密钥或公钥信息。
6. **服务器Hello Done**：
    - 服务器发送 `ServerHelloDone` 消息，表示它已经完成了握手阶段。
7. **客户端完成（Finished）**：
    - 客户端通过计算并发送一个加密的哈希值（`Finished`），用于验证握手过程的完整性。
8. **服务器完成（Finished）**：
    - 服务器接收到客户端的 `Finished` 消息后，也会发送一个加密的 `Finished` 消息，表示服务器已完成握手。
    
    **此时，握手阶段完成，双方可以开始安全的加密通信。**

---

#### **2. 数据传输阶段（Record Phase）**

在完成握手后，双方已经生成了共享的会话密钥（称为对称密钥），此时进入数据传输阶段。TLS 协议通过以下步骤保证数据的安全传输：

9. **数据加密**：
    - 客户端和服务器使用共享的会话密钥对发送的数据进行对称加密（如使用 AES、ChaCha20 等对称加密算法）。
10. **数据完整性校验**：
    - 为了防止数据在传输过程中被篡改，TLS 使用消息认证码（MAC）进行完整性校验。每个加密的数据包都附带一个MAC，接收方会验证数据包是否被篡改。
11. **数据压缩（可选）**：
    - 在传输过程中，可以选择启用数据压缩以提高传输效率，但在TLS 1.3中，已取消了压缩的使用。
12. **安全数据传输**：
    - 客户端和服务器通过加密的通道交换加密数据。这些加密的消息是保密的，并且通过验证的完整性来保证数据没有被篡改。
13. **会话关闭**：
    - 一旦数据传输完成，双方会进行会话关闭的过程。客户端发送 `close_notify` 消息，服务器回复同样的消息，确保没有任何数据丢失。

---

### **TLS 握手过程的简化流程图**

14. **ClientHello**
    - 客户端发送支持的加密套件、版本等信息。
15. **ServerHello + Server Certificate**
    - 服务器选择加密套件并发送其证书。
16. **密钥交换**
    - 双方交换密钥信息（如通过RSA、Diffie-Hellman等）。
17. **ClientKeyExchange + Finished**
    - 客户端发送加密的预主密钥并验证握手过程的完整性。
18. **Server Finished**
    - 服务器验证客户端的 `Finished` 并发送自己的 `Finished`。
19. **数据传输**（加密、完整性验证）
---

### 总结

- **握手阶段**确保了安全的通信环境，通过交换密钥、身份验证和加密套件选择建立加密通道。
- **数据传输阶段**使用对称加密进行安全的数据传输，并确保数据完整性。
- TLS通过使用加密和认证技术，确保通信过程中的数据不被窃听、篡改或伪造。

# 6. TCP 和 UDP 的区别是什么

TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）是两种不同的传输层协议，主要用于网络通信。它们的核心区别在于**可靠性**、**连接方式**和**传输效率**

![[Pasted image 20250305151130.png]]

**简单来说：**
- **TCP** 适用于需要**数据完整性和可靠性**的应用，如网页、文件传输、邮件等。
- **UDP** 适用于需要**速度和低延迟**，但可以容忍部分丢包的应用，如直播、游戏、DNS 查询等。

# 7. 为什么延迟低的场景使用 UDP？UDP 为什么性能会比 TCP 更好

在**低延迟场景**（如实时音视频、在线游戏、直播等）通常选择 **UDP** 而不是 **TCP**，主要原因在于 UDP **无连接、无状态、无确认机制**，因此在数据传输的**时延和性能**上比 TCP **更快**。以下是具体原因：
### **1. UDP 为什么延迟低？**

#### **① 无连接，不需要建立握手**

- **UDP 直接发送数据**，不需要像 TCP 那样进行**三次握手**来建立连接，避免了额外的时间开销。
- **TCP 需要三次握手**（约 1~2 个 RTT，往返时间），这在高延迟或丢包率高的网络环境下会进一步增加启动延迟。
- **UDP 可以立即发送数据**，非常适合**实时性要求高**的应用，如视频通话、游戏数据包等。

#### **② 无状态，服务器不维护连接**

- UDP 服务器不需要维护客户端的连接状态，每个数据包都是独立的，因此处理速度快，适用于**高并发**场景。
- TCP 服务器必须维护每个连接的状态，包括序列号、窗口大小、缓存等，**消耗大量内存**，连接数过多时会影响性能。

#### **③ 无流量控制，不会被 TCP 拥塞控制阻塞**

- **TCP 有流量控制**，如果网络出现拥塞，TCP 会降低发送速率，导致数据延迟。
- **UDP 没有流量控制**，即使网络拥塞，数据仍然会尽可能快速地发送出去，不会等待确认，避免了**Nagle 算法**带来的发送延迟。

#### **④ 无确认机制，避免了重传导致的额外延迟**

- TCP 通过**ACK 确认**确保数据可靠传输，但这需要额外的 RTT（往返时间）。
- 如果数据丢失，**TCP 需要重传**，进一步增加延迟。
- UDP **不等待确认**，即使数据丢失，也不会影响整体通信。例如，在视频直播或语音通话中，**丢失一帧数据不会影响播放**，但 TCP 的重传可能导致画面卡顿或音频延迟。

#### **⑤ 数据包顺序问题**

- **TCP 需要保证数据按顺序到达**，如果数据包乱序，TCP 需要缓存乱序数据，等待缺失的包到达后再处理，**导致额外的延迟**。
- **UDP 不关心顺序**，收到哪个包就处理哪个包，适用于**实时应用**（如游戏、直播、VoIP），即使数据丢失，用户也不会感受到明显影响。
### **2. UDP 为什么性能比 TCP 更好？**

#### **① 头部开销小，减少传输时间**

|**协议**|**TCP 头部**|**UDP 头部**|
|---|---|---|
|**大小**|**20~60 字节**|**8 字节**|

- UDP 头部 **仅 8 字节**，而 TCP 头部 **至少 20 字节**，在大规模数据传输时，UDP 具有更小的网络开销，减少了带宽占用，提高了传输速度。

#### **② 处理速度快，适合高并发**

- TCP 需要维护 **连接状态、窗口大小、重传队列、流量控制、拥塞控制**，CPU 负担大。
- UDP **不维护连接状态**，适用于**高并发**服务器，比如**DNS 服务器**可以每秒处理**数百万请求**。

#### **③ 没有握手、重传，减少 CPU 计算和网络开销**

- **TCP 需要维护大量状态信息**（如确认号、窗口大小、重传队列等）。
- **UDP 只发送数据**，不关心是否成功到达，**计算量更少，CPU 负担更低**。
### **3. 总结**

- **UDP 的低延迟优势** 来自于：
    
    - **无需握手**（减少 RTT）
    - **无连接、无状态**（服务器处理快，适合高并发）
    - **无流量控制**（避免 TCP 拥塞控制带来的延迟）
    - **无重传**（防止重传导致的额外等待时间）
    - **小数据包头**（减少传输开销）
- **UDP 的高性能优势**：
    
    - 处理速度快，服务器负担低，适用于**高并发场景**（如 DNS、视频直播、游戏）。
    - 头部小，带宽开销低，适用于**实时应用**（如 IoT、VoIP）。

# 8. Cookie vs Session 的区别

**Cookie 和 Session 都用于在 Web 应用中存储用户会话信息**，但它们的**存储方式、作用范围、安全性**等有所不同。

---

## **1️⃣ 核心区别对比**

|**对比项**|**Cookie**|**Session**|
|---|---|---|
|**存储位置**|**浏览器端**（客户端）|**服务器端**|
|**数据大小**|**最大 4KB**|**受服务器内存限制**|
|**安全性**|**低**（数据存储在客户端，可能被篡改）|**高**（数据存储在服务器）|
|**生命周期**|**默认浏览器关闭即失效**，可手动设置过期时间|**默认 Session 关闭即失效**，可设置超时时间|
|**跨域支持**|**支持**（同一域名下可访问）|**不支持跨域**（基于服务器存储）|
|**存储方式**|以 **键值对（key=value）** 存储字符串|**存储对象，可存放更多数据**|
|**性能影响**|**占用客户端资源**，不影响服务器|**占用服务器内存**，大量 Session 可能影响性能|
|**适用场景**|**存储用户偏好、保持登录状态、广告投放**|**存储用户会话信息、购物车、身份验证**|

---

## **2️⃣ 详细解析**

### **✅ Cookie**

- **存储在客户端**（浏览器），随请求发送到服务器。
- **适用于跨请求存储小数据**（如用户 ID、Token）。
- **易被篡改或窃取**，敏感数据需要加密。

📌 **适用场景**

- 记住用户登录状态（如 `remember me`）。
- 统计用户行为（如 Google Analytics）。
- **广告投放**（存储用户兴趣标签）。

---

### **✅ Session**

- **存储在服务器**，客户端只存 **Session ID（`JSESSIONID`）**。
- **数据不会暴露给客户端**，更安全。
- **适用于存储用户会话数据**（如购物车、权限信息）。

📌 **适用场景**

- **用户身份认证**（存储用户 ID）。
- **购物车**（存储选购商品）。
- **网站个性化设置**（存储用户配置）。

---

## **3️⃣ Cookie 和 Session 配合使用**

- **Cookie 存储 `SessionID`，Session 存储用户数据**。
- **服务器可通过 `SessionID` 识别用户并获取数据**。

📌 **示例**

1. **用户登录后，服务器生成 `Session`，存储用户信息**。
2. **服务器返回 `Set-Cookie: JSESSIONID=abc123; HttpOnly`，让浏览器保存**。
3. **浏览器每次请求时，自动带上 `JSESSIONID`，服务器从 Session 读取用户信息**。

---

## **4️⃣ 选择 Cookie 还是 Session？**

✅ **用 Cookie**

- 存储小型数据（如 `theme=dark`）。
- **跨会话存储**（如记住用户登录状态）。
- **服务器无状态**（如 REST API 认证 Token）。

✅ **用 Session**

- **存储用户会话数据**（如购物车、用户信息）。
- **更安全**（不暴露敏感数据给客户端）。
- **短时间存储交互数据**（如 Web 端身份认证）。

🚀 **最佳实践**：**结合使用 Cookie（存 SessionID）+ Session（存用户数据），兼顾安全性和性能！** 🔥

# 9. TCP 三次握手后，服务端网络延迟时客户端如何保证传输可靠性？

在 **TCP 三次握手** 成功后，客户端和服务端之间建立了**可靠的双向连接**，但如果**服务端网络出现延迟**，TCP 仍然可以通过多种机制保证数据传输的可靠性。

---

## **1️⃣ TCP 如何保证传输的可靠性？**

### **📌 1. 可靠传输机制**

TCP 通过 **超时重传、流量控制、拥塞控制等机制**，确保数据可靠送达。

| **机制**                   | **作用**                    |
| ------------------------ | ------------------------- |
| **ACK 确认机制**             | 发送方必须收到 ACK 确认，否则会重传数据    |
| **超时重传机制（RTO）**          | 如果一定时间内未收到 ACK，TCP 重新发送数据 |
| **流量控制（Sliding Window）** | 服务器接收能力下降时，调整发送窗口，避免丢包    |
| **拥塞控制（慢启动、拥塞避免）**       | 防止网络拥塞导致数据丢失              |
| **乱序重组**                 | 数据乱序到达时，TCP 按序重组数据        |

---

## **2️⃣ 服务端网络延迟对 TCP 影响**

如果 **服务端网络出现延迟**，可能导致：

1. **ACK 确认变慢** → 客户端等待 ACK 时间变长，可能触发 **超时重传**。
2. **TCP 滑动窗口缩小** → 服务端响应慢，导致 TCP 发送窗口减小，客户端发送速度下降。
3. **网络拥塞** → 可能触发 TCP **拥塞控制**，进一步降低数据传输速率。

---

## **3️⃣ 客户端如何应对服务端网络延迟？**

### **📌 1. 超时重传机制**

- **TCP 设定 RTO（重传超时）**，如果在**一定时间内未收到 ACK**，客户端会**自动重传数据**。
- **动态调整 RTO**，TCP 会根据往返时间（RTT）调整超时时间，避免过早或过晚重传。

### **📌 2. 滑动窗口 & 流量控制**

- **如果服务端延迟导致 ACK 变慢**，TCP 可能减少窗口大小，客户端会**降低发送速率**，避免丢包。
- **当服务端恢复正常**，TCP 发送窗口会**逐步增大，恢复正常传输速度**。

### **📌 3. 拥塞控制**

- TCP **检测到延迟增加**（RTT 变大），可能会进入 **拥塞避免阶段**，减少数据发送速率，**防止丢包**。
- **慢启动**：如果服务端恢复，TCP 会**逐步提高发送速率**，避免网络抖动。

### **📌 4. KeepAlive 保持连接**

- 如果网络延迟过久，客户端可能会**发送 KeepAlive 探测包**，确保连接仍然有效，避免因长时间未收到数据而断开。

### **📌 5. 应用层重试**

- 如果 TCP **多次重传仍未成功**，应用层（如 HTTP、RPC）可能会**触发重试机制**，尝试重新发送请求。

---

## **4️⃣ 结论**

|**服务端网络延迟问题**|**TCP 保障方式**|
|---|---|
|**ACK 变慢**|超时重传（RTO）|
|**流量控制触发**|滑动窗口调整|
|**网络拥塞**|拥塞控制（慢启动）|
|**长时间无响应**|KeepAlive 探测|
|**重传失败**|应用层重试（如 HTTP 5xx 自动重试）|

🚀 **TCP 通过超时重传、流量控制、拥塞控制等机制，即使服务端网络延迟，也能保证数据可靠传输！🔥**

# 10. DNS

## **1️⃣ 什么是 DNS？**

**DNS（Domain Name System，域名系统）** 是 **互联网的“电话簿”**，负责将**域名（如 www.google.com）解析为 IP 地址（如 142.250.72.206）**，让用户可以**使用易记的域名访问网站**，而不需要记住复杂的 IP 地址。

---

## **2️⃣ DNS 的核心作用**

|**作用**|**说明**|
|---|---|
|**域名解析**|将 **域名** 转换为 **IP 地址**，使用户可以访问网站|
|**负载均衡**|通过 **返回不同 IP**，将流量分配到多个服务器|
|**CDN 加速**|DNS **解析到最近的 CDN 服务器**，提升访问速度|
|**邮件路由**|使用 **MX 记录** 指定邮件服务器，提高邮件送达率|

---

## **3️⃣ DNS 解析流程**

当用户在浏览器输入 `www.google.com` 时，DNS 解析的完整流程如下：

1. **浏览器缓存**：首先检查本地缓存是否已解析过该域名，若有则直接返回 IP。
2. **操作系统缓存**：若浏览器无缓存，查询本地系统的 DNS 缓存（如 `hosts` 文件）。
3. **本地 DNS 服务器（ISP 提供）**：
    - 向 **本地 DNS 服务器（ISP 提供）** 发送请求。
    - 若有缓存，则直接返回结果。
    - 若无缓存，则递归查询权威 DNS 服务器。
4. **根 DNS 服务器**：
    - 返回该域名所属的顶级域（如 `.com`）的 **TLD 服务器地址**。
5. **TLD（顶级域）服务器**：
    - 负责 `.com` 解析，返回**权威 DNS 服务器地址**。
6. **权威 DNS 服务器**：
    - 负责该域名的最终解析，返回网站的 **IP 地址**。
7. **本地 DNS 服务器缓存结果**，加速下次查询。

🔹 **最终，用户的浏览器获取 IP 地址，并访问目标服务器。**

---

## **4️⃣ DNS 记录类型**

| **记录类型**     | **作用**                | **示例**                               |
| ------------ | --------------------- | ------------------------------------ |
| **A 记录**     | **域名 → IPv4 地址**      | `www.example.com → 192.168.1.1`      |
| **AAAA 记录**  | **域名 → IPv6 地址**      | `www.example.com → 2400:cb00::1`     |
| **CNAME 记录** | **别名解析**，将一个域名指向另一个域名 | `blog.example.com → www.example.com` |
| **MX 记录**    | **邮件服务器** 地址解析        | `mail.example.com`                   |
| **NS 记录**    | 指定 **DNS 服务器**        | `ns1.example.com`                    |

---

## **5️⃣ DNS 的优点**

|**优点**|**说明**|
|---|---|
|**提高可用性**|通过 **负载均衡**，避免单点故障|
|**加快访问速度**|通过 **缓存、CDN** 提供更快解析|
|**分布式架构**|**全球分布式服务器**，高可扩展性|
|**提高安全性**|通过 **DNSSEC、DDoS 防护** 增强安全性|

---

## **6️⃣ DNS 的缺点**

|**缺点**|**说明**|
|---|---|
|**解析速度受网络影响**|解析时间受 **网络拥堵、缓存命中率** 影响|
|**容易被攻击（DNS 劫持）**|可能被 **DNS 污染、DDoS 攻击**|
|**缓存一致性问题**|**DNS 缓存** 可能导致域名变更后无法立刻生效|

---

## **7️⃣ DNS 相关优化**

|**优化方式**|**作用**|
|---|---|
|**CDN + DNS 解析**|解析到最近的 CDN 节点，加快访问速度|
|**负载均衡**|解析到不同服务器，均衡流量|
|**DNS 预解析**|提前解析域名，减少页面加载时间|
|**启用 DNSSEC**|保障解析安全性，防止 DNS 劫持|

---

## **8️⃣ 结论**

- **DNS 是互联网的“电话簿”，负责将域名解析为 IP 地址**。
- **采用层级查询结构（根 DNS → TLD → 权威 DNS），提高解析效率**。
- **支持 A 记录、CNAME、MX 记录等多种解析方式，适用于不同应用场景**。
- **使用缓存、CDN、负载均衡等优化 DNS 解析，提高网站性能和安全性**。

🚀 **理解 DNS 机制，有助于优化网站访问速度，提升系统可靠性！🔥**

# 11. HTTPS 版本之间的区别

## **1️⃣ 什么是 HTTPS？**

HTTPS（HyperText Transfer Protocol Secure）是 **HTTP + TLS/SSL** 的加密协议，主要用于 **保证数据传输的安全性**，防止 **窃听、中间人攻击、数据篡改**。

不同版本的 **TLS（Transport Layer Security）** 决定了 HTTPS 的安全级别和性能。

---

## **2️⃣ HTTPS 主要版本（基于 TLS 版本）**

|**版本**|**发布时间**|**主要特点**|**当前状态**|
|---|---|---|---|
|**SSL 3.0**|1996|最早的加密协议，存在漏洞|**已弃用**（POODLE 攻击）|
|**TLS 1.0**|1999|第一个标准化 TLS 版本，支持 SHA-1|**已弃用**（2020 年被各大浏览器禁用）|
|**TLS 1.1**|2006|增强安全性，支持 SHA-256|**已弃用**（2020 年被各大浏览器禁用）|
|**TLS 1.2**|2008|支持 AES-GCM、HMAC、SHA-256，提高安全性|**当前广泛使用（推荐）**|
|**TLS 1.3**|2018|改进握手速度，减少 RTT，移除不安全算法|**最新版本，最高安全性（推荐）**|

---

## **3️⃣ HTTPS 版本之间的区别**

### **📌 1. SSL 3.0 vs. TLS 1.0**

- **SSL 3.0** 存在 **POODLE 攻击漏洞**，被认为 **不安全**。
- **TLS 1.0** 引入了 **SHA-1 签名**，比 SSL 3.0 更安全，但仍然不够强。

🔹 **当前状态**：**SSL 3.0 和 TLS 1.0 已被弃用**，主流浏览器 **不再支持**。

---

### **📌 2. TLS 1.1 vs. TLS 1.2**

- **TLS 1.1 仍然依赖 SHA-1**，加密较弱，性能一般。
- **TLS 1.2 采用更强的 SHA-256、AES-GCM 加密，支持 HMAC 认证**，安全性更高。

🔹 **当前状态**：

- **TLS 1.1 被淘汰**（2020 年起，各大浏览器禁用）。
- **TLS 1.2 是当前最广泛使用的版本**。

---

### **📌 3. TLS 1.2 vs. TLS 1.3**

|**区别**|**TLS 1.2**|**TLS 1.3**|
|---|---|---|
|**握手速度**|**2-RTT**（两次往返）|**1-RTT**（一次往返），减少延迟|
|**加密算法**|允许 **不安全的算法**（如 RSA、CBC 模式）|**移除弱算法**（仅支持安全加密，如 ChaCha20）|
|**前向安全性**|可选|**默认开启**（防止数据回溯解密）|
|**密钥交换**|支持 RSA、ECDHE|**仅支持 ECDHE，安全性更高**|

🔹 **TLS 1.3 速度更快、加密更强，但兼容性较低**。

---

## **4️⃣ 各 HTTPS 版本的适用场景**

|**场景**|**推荐使用的 HTTPS 版本**|
|---|---|
|**金融系统（银行、支付）**|**TLS 1.3**（最高安全性）|
|**大型互联网平台（电商、社交）**|**TLS 1.3 或 TLS 1.2**|
|**一般企业网站**|**TLS 1.2**（兼容性好）|
|**老旧系统（WinXP 兼容）**|**TLS 1.2**（尽量避免 TLS 1.0/1.1）|

---

## **5️⃣ 结论**

- **SSL 3.0、TLS 1.0、TLS 1.1 已被淘汰，不推荐使用**。
- **TLS 1.2 是当前最广泛使用的版本，适用于大多数场景**。
- **TLS 1.3 提供更快的握手速度、更高的安全性，适用于高安全需求的系统**。

🚀 **新系统优先采用 TLS 1.3，旧系统可使用 TLS 1.2 以保证兼容性！🔥**

# 12. WebSocket 多路复用的实现原理

## **1️⃣ 什么是 WebSocket？**

**WebSocket** 是一种 **全双工（Full-Duplex）通信协议**，允许**客户端和服务器之间建立持久连接**，进行**实时数据交互**。它基于 TCP **单连接**，但可以同时处理多个数据流，实现多路复用。

---

## **2️⃣ WebSocket 多路复用的核心原理**

**WebSocket 通过“帧（Frame）”机制实现多路复用**，在一个 TCP 连接中，可以同时发送多个逻辑数据流，而无需为每个数据流单独建立 TCP 连接。

🔹 **核心概念**：

|**术语**|**说明**|
|---|---|
|**连接（Connection）**|一个 TCP 连接，WebSocket 在其中传输数据|
|**消息（Message）**|由多个帧组成，一个完整的数据包|
|**帧（Frame）**|WebSocket 传输的最小数据单元|
|**数据通道（Channel）**|通过不同的帧 ID 复用多个消息流|

---

## **3️⃣ WebSocket 多路复用的实现流程**

### **📌 1. 建立 WebSocket 连接**

- 客户端通过 **HTTP `Upgrade` 请求** 发送 WebSocket 握手请求：
    `GET /chat HTTP/1.1 Upgrade: websocket Connection: Upgrade`
    
- 服务器响应 `101 Switching Protocols`，升级协议，建立 WebSocket 连接。

---

### **📌 2. WebSocket 采用帧（Frame）传输**

WebSocket **使用帧（Frame）进行数据传输**，支持**不同的帧类型**：

|**帧类型**|**作用**|
|---|---|
|**文本帧（Text Frame）**|传输文本数据（UTF-8 编码）|
|**二进制帧（Binary Frame）**|传输二进制数据（如音视频流）|
|**控制帧（Control Frame）**|关闭连接（Close）、Ping、Pong|

🔹 **WebSocket 通过帧机制复用数据流**：

- **多个数据流共享同一个 WebSocket 连接**，每个流用**帧 ID 或标识符区分**。
- **服务器可以并行处理多个数据流**，而无需为每个流单独建立连接。

---

### **📌 3. 多个数据流共享 WebSocket 连接**

在 **单个 WebSocket 连接** 内，可以同时传输多个逻辑数据流，如：

- **聊天数据**
- **实时通知**
- **视频流**
- **股票行情**

每个数据流通过 **不同的帧 ID 或消息标识符** 区分，客户端和服务器根据**帧 ID** 解析不同的消息流。

---

## **4️⃣ WebSocket 多路复用的优势**

|**优势**|**说明**|
|---|---|
|**减少 TCP 连接数**|**所有数据流共享一个 TCP 连接**，减少连接开销|
|**低延迟（实时通信）**|**WebSocket 采用持久连接**，减少握手时间，提高交互速度|
|**高效传输**|**通过帧（Frame）机制，实现并发数据流**|
|**节省带宽**|**支持数据压缩，减少流量消耗**|

---

## **5️⃣ WebSocket vs. HTTP/2 多路复用**

|**特点**|**WebSocket**|**HTTP/2**|
|---|---|---|
|**连接**|单 TCP 连接|单 TCP 连接|
|**通信方式**|**双向（全双工）通信**|**客户端-服务器请求响应模式**|
|**传输单位**|**帧（Frame）**|**流（Stream）**|
|**适用场景**|**实时通信（聊天、游戏、推送）**|**网页加载优化（并发请求）**|

---

## **6️⃣ 结论**

- **WebSocket 通过帧（Frame）机制，实现多路复用，多个数据流共享一个 TCP 连接**。
- **相比 HTTP/2，多路复用在 WebSocket 上实现的是双向实时通信，更适合实时消息推送**。
- **广泛用于在线聊天、股票行情、协作系统等需要高并发、低延迟的场景**。


# 13. GET 和 POST 的区别

## **1️⃣ 定义**

- **GET**：用于 **获取资源**，通常用于请求页面、查询数据。
- **POST**：用于 **提交数据**，通常用于表单提交、上传文件等。

---

## **2️⃣ 主要区别**

|**对比项**|**GET**|**POST**|
|---|---|---|
|**作用**|获取资源|发送数据到服务器|
|**数据传输方式**|**URL 参数**（`?key=value`）|**请求体（Body）**|
|**数据长度**|URL 长度有限（一般 2048 字节）|理论上**无限制**|
|**是否缓存**|**可被缓存**（浏览器缓存）|**默认不缓存**|
|**安全性**|**不安全**（数据暴露在 URL）|**较安全**（数据在请求体）|
|**幂等性**|**幂等**（多次请求结果相同）|**非幂等**（多次提交可能创建多条数据）|
|**请求参数**|**只能使用 URL 传递参数**|**可使用 URL + Body 传递参数**|
|**性能**|**更快**（直接通过 URL 获取缓存）|**稍慢**（数据处理更多）|

---

## **3️⃣ 适用场景**

|**使用场景**|**推荐方法**|
|---|---|
|获取网页、查询数据|**GET**|
|提交表单、用户注册、登录|**POST**|
|发送敏感数据（密码、银行卡）|**POST**|
|需要重复请求但不影响数据|**GET**|
|需要上传文件|**POST**|

---

## **4️⃣ 结论**

- **GET 适用于数据查询，URL 传参，支持缓存，幂等**。
- **POST 适用于数据提交，支持大数据传输，非幂等，安全性更高**。
- **选择合适的方法，有助于优化 API 设计，提高安全性！🔥**