# 1. Java中32无符号整型怎么存储

在Java中，**`int`** 是一个 32 位的有符号整数类型，其值的范围为 `-2^31` 到 `2^31-1`（即 `-2147483648` 到 `2147483647`）。而 Java 本身并不直接支持无符号 32 位整型 (`unsigned int`)，但可以通过一些方式处理无符号数。

对于32位无符号整数（`unsigned int`），其值范围是 `0` 到 `2^32 - 1`（即 `0` 到 `4294967295`）。虽然 Java 的 `int` 类型不支持无符号表示，但你可以通过 `long` 类型（64 位）来存储无符号的 32 位整数。


# 2. 深拷贝 vs. 浅拷贝

在编程中，**对象的拷贝方式**主要分为**浅拷贝（Shallow Copy）** 和 **深拷贝（Deep Copy）**，它们的区别在于**是否复制对象的引用类型属性（内存地址）**。

---

## **1️⃣ 浅拷贝（Shallow Copy）**

### **📌 1.1 定义**

**浅拷贝只复制对象的基本类型属性，而引用类型属性仍然指向原对象的内存地址**。

### **📌 1.2 浅拷贝的特点**

- **基本数据类型（int, float, boolean, char）** 被完整复制。
- **引用类型（对象、数组、集合等）** 只是复制了 **地址（引用）**，两个对象共享相同的内存。

### **📌 1.3 浅拷贝的问题**

- **修改新对象的引用属性，会影响原对象**，因为它们指向相同的内存地址。

🔹 **示例（浅拷贝的问题）**

|**对象**|**原始数据**|**修改后数据**|
|---|---|---|
|**原对象 A**|`list = [1,2,3]`|`list = [1,2,99]`|
|**拷贝对象 B**|`list = [1,2,3]`|`list = [1,2,99]`（也被修改）|

---

## **2️⃣ 深拷贝（Deep Copy）**

### **📌 2.1 定义**

**深拷贝不仅复制基本类型数据，还会递归复制所有引用类型属性，使新对象完全独立于原对象**。

### **📌 2.2 深拷贝的特点**

- **基本数据类型会复制值**。
- **引用类型（数组、对象、集合等）会递归复制新的副本**，不再指向原对象的地址。

### **📌 2.3 深拷贝的优点**

- **修改新对象不会影响原对象**，完全独立存储。

🔹 **示例（深拷贝后不会影响原对象）**

|**对象**|**原始数据**|**修改后数据**|
|---|---|---|
|**原对象 A**|`list = [1,2,3]`|`list = [1,2,3]`（未变）|
|**拷贝对象 B**|`list = [1,2,3]`|`list = [1,2,99]`（独立修改）|

---

## **3️⃣ 浅拷贝 vs. 深拷贝 对比**

|**对比项**|**浅拷贝（Shallow Copy）**|**深拷贝（Deep Copy）**|
|---|---|---|
|**基本类型（int, float, char）**|直接复制值|直接复制值|
|**引用类型（对象、数组、集合）**|复制**内存地址**（共享数据）|**递归复制新对象**（数据独立）|
|**修改副本数据**|**会影响原对象**|**不会影响原对象**|
|**复制效率**|**快**（只复制地址）|**慢**（递归复制）|
|**适用场景**|数据变化少，只读场景|需要**完全独立对象**|

---

## **4️⃣ 适用场景**

|**适用情况**|**推荐方式**|
|---|---|
|**对象包含大量不可变数据**|**浅拷贝**，避免不必要的内存占用|
|**对象内部有复杂引用类型（数组、集合）**|**深拷贝**，避免共享引用导致数据污染|
|**多线程环境，数据隔离**|**深拷贝**，防止并发修改数据|

---

## **5️⃣ 结论**

- **浅拷贝仅复制基本数据类型，对象引用指向相同内存**，修改副本会影响原数据。
- **深拷贝会递归复制所有数据，新对象独立于原对象**，修改不会影响原数据。
- **浅拷贝适用于只读场景，深拷贝适用于多线程或数据隔离需求**。

# 3. 抽象类与接口的区别

![[Pasted image 20250304180135.png]]

# 4. 多态的理解

**多态**（Polymorphism）是面向对象编程中的核心概念之一，它指的是同一个方法调用在不同对象上表现出不同的行为。简而言之，就是“一个接口，多种实现”。

在Java中，多态通常通过**方法重载**和**方法重写**来实现。具体来说：

### 1. **方法重载**（Overloading）

方法重载是指在同一个类中，多个方法具有相同的方法名，但参数的类型、个数或顺序不同。方法的返回类型不影响重载。
### 2. **方法重写**（Overriding）

方法重写是指子类重新定义父类的某个方法，使其行为有所不同。重写的方法必须与父类中被重写的方法具有相同的方法签名（方法名、参数列表和返回类型）。
### 多态的关键点

1. **父类引用指向子类对象**：多态最常见的形式是，父类类型的引用指向子类的对象。
2. **动态方法调用**：在运行时，JVM会根据实际对象类型调用相应的方法，而不是根据引用类型调用。
### 多态的优点：

- **可扩展性**：通过继承和方法重写，可以方便地扩展程序功能。
- **可维护性**：通过接口或抽象类，子类可以根据具体需求实现不同的行为，提高代码的灵活性和可维护性。

# 5. 为什么设置JVM启动内存

1. **确保内存充足**：
    - JVM 的运行需要内存。如果没有足够的内存，程序可能会抛出 **OutOfMemoryError** 错误，导致程序崩溃。
    - 设置适当的内存大小可以确保 JVM 在执行时拥有足够的空间来执行复杂操作、加载大量数据或创建多个对象。
2. **优化程序性能**：
	- 内存的设置直接影响 JVM 的垃圾回收机制。通过合理调整堆内存大小，可以提高垃圾回收的效率，减少频繁的垃圾回收操作。
    - 对于大规模数据处理的程序，适当增加堆内存有助于提高性能，减少因内存不足导致的频繁回收或内存溢出。
3. **控制内存使用**：
    - Java 程序通常运行在生产环境中，可能需要与其他应用程序共享机器的内存资源。通过设置内存大小，可以限制 JVM 使用的内存，以避免它占用过多资源，从而影响其他进程的运行。
4. **避免过度分配内存**：
    - 如果为 JVM 设置过大的内存，虽然不会导致程序崩溃，但会浪费系统资源，导致计算机内存不足，甚至影响到其他进程。通过合理设置内存大小，可以确保资源得到有效利用。

# 6. \==和equals的区别

### 1. `==`（比较引用/基本数据类型值）

- **用于基本数据类型**（如 `int`、`char`、`boolean` 等）：直接比较 **值** 是否相等。
- **用于引用类型**（如 `String`、`Object` 等）：比较的是 **对象在堆内存中的引用地址** 是否相同，而不是对象的内容。
### 2. `equals()`（比较对象内容）

- **默认行为（Object类的 `equals()`）**：和 `==` 相同，比较的是对象的引用地址。
- **被重写的 `equals()`**（如 `String`、`Integer` 等）：用于比较 **对象的内容** 是否相等，而不关心内存地址。

# 7. equals()有什么限制

在 Java 中，`equals()` 方法有以下几个限制或需要遵循的规则（来自 Java 规范）：

1. **自反性（Reflexive）**
    - 对于任何非空引用值 `x`，`x.equals(x)` 必须返回 `true`。
2. **对称性（Symmetric）**
    - 对于任何非空引用值 `x` 和 `y`，如果 `x.equals(y)` 返回 `true`，那么 `y.equals(x)` 也必须返回 `true`。
3. **传递性（Transitive）**
    - 如果 `x.equals(y)` 返回 `true`，并且 `y.equals(z)` 返回 `true`，那么 `x.equals(z)` 也必须返回 `true`。
4. **一致性（Consistent）**
    - 如果 `x.equals(y)` 在 `x` 和 `y` 未被修改的情况下始终返回 `true`，则每次调用 `x.equals(y)` 都应该返回相同的结果。
5. **与 `null` 的比较（Non-nullity）**
    - 对于任何非空引用 `x`，`x.equals(null)` 必须返回 `false`，不能抛出异常。

# 8. 为什么 `equals()` 需要和 `hashCode()` 一起重写

在 Java 中，如果重写了 `equals()`，通常也 **必须** 重写 `hashCode()`，主要原因是 **Hash 相关的集合依赖 `hashCode()` 进行存储和查找**（如 `HashMap`、`HashSet`、`Hashtable`）。如果 `equals()` 和 `hashCode()` 不匹配，可能会导致集合无法正常工作。
#### **`hashCode()` 相关规则**
1. **如果 `equals()` 判断两个对象相等，则它们的 `hashCode()` 值必须相等**。
    - 这样才能保证哈希集合正确存储和查找对象。
2. **如果 `equals()` 判断两个对象不相等，`hashCode()` 值可以相同，但尽量减少哈希冲突**。
    - 即使两个对象的 `hashCode()` 相同（哈希冲突），哈希表仍然可以正确存储它们，但性能可能会下降。
#### **如果只重写 `equals()` 而不重写 `hashCode()`，可能会导致的问题**
- 在 `HashSet` 中：
    - 如果 `equals()` 认为两个对象相等，但 `hashCode()` 返回不同的值，那么 `HashSet` 可能会存入 **重复对象**，因为 `HashSet` 依赖 `hashCode()` 进行索引。
- 在 `HashMap` 中：
    - 如果 `hashCode()` 没有正确重写，即使 `equals()` 认为两个对象相等，`HashMap.get()` 可能无法正确找到该对象，因为哈希表依赖 `hashCode()` 进行数据存储和查找。
### **总结**

- `equals()` 确保对象 **内容相等**，`hashCode()` 确保 **相等的对象有相同的哈希值**。
- Java 规范要求：**如果 `equals()` 判断两个对象相等，则 `hashCode()` 必须返回相同的值**。
- `HashSet`、`HashMap` 等哈希结构依赖 `hashCode()` 进行存储和查找，若不同时重写 `hashCode()`，可能导致 **查找失败、重复存储或性能下降**。
- 最佳实践：**始终同时重写 `equals()` 和 `hashCode()`** 以确保哈希集合中的正确性和高效性。

# 9. Java一个子类可以继承多少个父类？可以实现多少个接口？

### **1. 一个子类可以继承多少个父类？**

**🔹 只能继承** **一个** **父类**（Java 只支持**单继承**）

- Java **不支持** C++ 那样的**多重继承**，即一个类**只能**继承**一个直接父类**。
- 这是为了**避免“菱形继承问题”**（即多个父类有相同的方法，导致子类不确定调用哪个版本）。


---
### **2. 一个类可以实现多少个接口？**

**🔹 可以实现** **多个** **接口**（Java 支持**多接口实现**）

- Java **允许一个类实现多个接口**，从而弥补了**不支持多重继承**的缺陷。
- 通过实现多个接口，一个类可以从**多个来源**继承方法签名（但必须自己提供实现）。

---

### **3. 为什么 Java 只支持单继承但支持多接口实现？**

#### **💡 Java 禁止多重继承的原因**

1. **菱形继承问题（Diamond Problem）**
    - 如果两个父类有相同的方法，子类不清楚应该调用哪个版本，容易产生**二义性**。
2. **代码复杂性**
    - 多重继承会导致继承关系混乱，使得代码难以维护。
3. **运行时效率**
    - 单继承结构让 JVM **更容易优化**，提高运行效率。

#### **💡 Java 允许多接口实现的原因**

1. **解决多重继承的缺陷**
    - 允许一个类从多个接口继承**方法签名**，但**不继承实现**，避免了二义性问题。
2. **接口解耦**
    - 接口使得 Java 具有**高度的灵活性和可扩展性**，支持面向接口编程（OOP）。
3. **默认方法（Java 8 引入）**
    - Java 8 之后，**接口可以有默认方法（default method）**，即便多个接口有相同的方法，也可以在子类中**显式指定**调用哪个版本。

---

### **总结**

|特性|继承|接口|
|---|---|---|
|**支持多个父级**|❌（只能继承一个父类）|✅（可以实现多个接口）|
|**是否有方法实现**|✅（父类方法可以有实现）|❌（接口的方法默认没有实现，Java 8 之后可以有 `default` 方法）|
|**是否会有多重继承问题**|✅（Java 禁止多重继承，避免菱形继承问题）|❌（接口没有状态，不会有二义性）|
|**使用场景**|需要**继承行为**和**属性**|需要**共享方法签名**，但不关心实现|

因此，在 Java 中：
- **一个子类只能继承一个父类**（单继承）。
- **一个类可以实现多个接口**（多接口实现）。

# 10. 抽象类的子类可以有抽象的方法吗?

**✅ 可以！**  
如果一个抽象类的子类**不想立即提供所有抽象方法的实现**，它可以**继续定义为抽象类**，并包含抽象方法。
#### **💡 什么时候适用？**

- 需要**进一步延续抽象**，但不想在当前子类实现所有抽象方法时，可以让子类继续保持抽象。
- **中间层抽象类**：如果一个抽象类有多个层级，可以让中间层的子类仍然是抽象类，部分实现方法，部分继续抽象。

✔ **结论**：**抽象类的子类可以继续是抽象类，并且可以包含新的抽象方法。只有最终的非抽象子类需要实现所有抽象方法。**

# 11. 包装类型与基础类型的区别

| 对比项    | 基本数据类型              | 包装类型                      |
| ------ | ------------------- | ------------------------- |
| 存储位置   | 栈（Stack）            | 堆（Heap）                   |
| 是否对象   | 不是对象                | 是对象（继承 `Object`）          |
| 默认值    | 具体数值（如 `0`、`false`） | `null`                    |
| 适用场景   | 高性能计算               | 需要对象特性，如集合                |
| 自动装箱拆箱 | 不支持                 | 支持                        |
| 比较方式   | `==` 比较值            | `==` 比较地址，`.equals()` 比较值 |

# 12. 装修拆箱的时机

|**操作**|**触发条件**|**示例**|
|---|---|---|
|**装箱（Autoboxing）**|基本类型 → 包装类型|`Integer obj = 10;`|
||方法参数是包装类型但传入基本类型|`printNumber(5);`|
||将基本类型存入集合|`list.add(10);`|
|**拆箱（Unboxing）**|包装类型 → 基本类型|`int num = obj;`|
||方法参数是基本类型但传入包装类型|`add(num);`|
||进行算术运算|`int sum = x + y;`|
||包装类型与基本类型比较运算|`System.out.println(a == b);`|

# 13. wait()和sleep()的区别

## **1️⃣ 定义与作用**

|方法|所属类|作用|
|---|---|---|
|`wait()`|`Object`|让线程**释放对象锁**，进入等待状态，直到被其他线程唤醒（`notify()` 或 `notifyAll()`）。|
|`sleep()`|`Thread`|让线程**暂停执行一段时间**，但不会释放锁，时间结束后自动恢复运行。|

---

## **2️⃣ 是否释放锁**

- **`wait()`** 会**释放对象锁**，允许其他线程获取锁并继续执行。
- **`sleep()`** **不会释放锁**，其他线程仍需等待当前线程结束睡眠后才可能获得锁。

---

## **3️⃣ 适用场景**

- **`wait()`** 适用于 **线程间通信**，通常与 `synchronized` 结合使用，使**线程进入等待状态，直到被唤醒**。
- **`sleep()`** 适用于 **让线程暂停执行** 一段时间，但**不会释放锁**，主要用于控制执行节奏或模拟延迟。

---

## **4️⃣ 唤醒方式**

- **`wait()`** 需要由**其他线程**调用 `notify()` 或 `notifyAll()` **手动唤醒**。
- **`sleep()`** 只需等待**时间到达**，自动恢复执行。

---

## **5️⃣ 适用范围**

- **`wait()`** 只能在 **同步方法或同步代码块（`synchronized`）内部**使用，否则会抛 `IllegalMonitorStateException`。
- **`sleep()`** 可以在**任何地方**使用，不受 `synchronized` 约束。

---

## **6️⃣ 异常**

- **`wait()`** 需要在 `synchronized` 代码块中调用，否则会抛 `IllegalMonitorStateException`。
- **`sleep()`** 需要处理 `InterruptedException`，因为线程可能在睡眠过程中被其他线程中断。

---

## **7️⃣ 执行对象**

- **`wait()`** 是 **对象级** 方法，作用于**持有该对象锁的线程**。
- **`sleep()`** 是 **线程级** 方法，只作用于**当前线程**。

---

## **总结**

|比较项|`wait()`|`sleep()`|
|---|---|---|
|**所属类**|`Object`|`Thread`|
|**释放锁**|✅ 释放锁|❌ 不释放锁|
|**恢复方式**|需 `notify()` / `notifyAll()` 唤醒|等待时间结束后自动恢复|
|**适用场景**|线程间通信|让线程暂停执行|
|**是否需要 `synchronized`**|✅ 需要|❌ 不需要|
|**抛出的异常**|`IllegalMonitorStateException`|`InterruptedException`|
|**作用对象**|作用于持有锁的线程|作用于当前线程|

**🚀 结论**

- **用 `wait()` 让线程等待并释放锁，等待其他线程唤醒。**
- **用 `sleep()` 让线程短暂休眠，但不会释放锁，适用于定时任务或模拟延迟。**

# 14. synchronized关键字

`synchronized` 是 Java 提供的一种**同步机制**，用于确保多线程访问**共享资源**时不会引起数据不一致或线程安全问题。它的主要作用是**保证同一时刻只有一个线程可以访问某个临界资源**，防止**竞态条件（Race Condition）**的发生。

---

## **1️⃣ `synchronized` 的作用**

- **保证原子性（Atomicity）**：确保线程对共享资源的操作是完整不可分割的。
- **保证可见性（Visibility）**：一个线程修改了共享变量，其他线程能立即看到修改后的值。
- **保证有序性（Ordering）**：确保操作按代码编写的顺序执行，防止指令重排序导致的并发问题。

---

## **2️⃣ `synchronized` 的使用方式**

`synchronized` 主要有三种使用方式：

### **✅ 2.1 修饰实例方法**

- 作用于**当前对象实例**，所有**访问该对象同步方法**的线程只能依次执行。
- **锁对象**：`this`（当前实例对象）。
- **影响范围**：同一个对象的不同线程不能同时执行该 `synchronized` 方法。

---

### **✅ 2.2 修饰静态方法**

- 作用于**整个类**，所有访问该类 `synchronized` 静态方法的线程只能依次执行。
- **锁对象**：`Counter.class`（类对象）。
- **影响范围**：所有线程共享该类的同一个锁，不管它们访问的是同一个实例还是不同实例。

---

### **✅ 2.3 修饰代码块**

- 作用于**指定的对象**，灵活控制加锁范围，提高并发性能。
- **锁对象**：`lock`（自定义锁对象）。
- **影响范围**：只对 `synchronized` 代码块加锁，而不会锁住整个方法，提高性能。

---

## **3️⃣ `synchronized` 的工作原理**

`synchronized` 依赖 **JVM 内部的对象监视器（Monitor）** 实现，具体流程如下：

1. **线程获取锁**（进入 `synchronized` 代码块）。
2. **执行同步代码**（保证线程安全）。
3. **释放锁**（同步代码执行完成或线程异常终止）。

💡 **底层实现**：

- **基于 `monitorenter` 和 `monitorexit` 指令**。
- **锁的升级机制（偏向锁 → 轻量级锁 → 重量级锁）** 提高性能，减少锁竞争。

---

## **4️⃣ `synchronized` 与其他锁机制的比较**

|特性|`synchronized`|`ReentrantLock`|
|---|---|---|
|**锁级别**|**对象锁 / 类锁**|**对象锁**|
|**是否可中断**|❌ 不可中断|✅ 可中断|
|**是否公平锁**|❌ 非公平|✅ 可选公平 / 非公平|
|**是否支持多个条件变量**|❌ 不支持|✅ 支持|
|**是否可尝试获取锁**|❌ 不能|✅ `tryLock()`|
|**性能**|**1.8 之后优化较好**|**适用于复杂锁需求**|

🚀 **结论**

- **简单同步** 用 `synchronized`，性能已优化，避免手动管理锁。
- **复杂锁机制** 用 `ReentrantLock`，如需要**公平锁、可中断、多个条件变量**。

---

## **5️⃣ `synchronized` 使用注意事项**

1. **避免锁住过大的范围**，影响并发性能：
    
    - ❌ **锁整个方法** `synchronized void method()`
    - ✅ **只锁必要部分** `synchronized (lock) { // 关键代码 }`
2. **避免锁住 `String` 常量**：
    
    - `synchronized ("lock") {}` **风险**：字符串常量池可能导致锁被多个地方共享，影响线程安全。
    - **推荐使用** `synchronized (new Object())` **或类字段锁**。
3. **避免死锁**：
    
    - 多线程加锁顺序不一致可能导致死锁，应**确保锁获取顺序一致**。

---

## **6️⃣ 总结**

|使用方式|作用范围|影响对象|适用场景|
|---|---|---|---|
|**实例方法**|**当前对象**|当前对象的所有线程|线程同步|
|**静态方法**|**整个类**|所有实例的线程|访问全局资源|
|**代码块**|**指定对象**|锁对象的所有线程|提高性能，局部加锁|

# 15. ReentrantLock 关键字

## **1️⃣ 什么是 ReentrantLock？**

`ReentrantLock` 是 Java 中的 **可重入锁**，它提供了比 `synchronized` 关键字 **更灵活、更强大的锁机制**，允许**一个线程多次获取同一把锁，而不会发生死锁**。

🔹 **"Reentrant"（可重入）** 指的是：

- **同一个线程可以多次获取同一把锁**，只需释放相同次数。
- 例如：线程 A 获取锁后，可以在**同一线程的不同方法**中**再次获取**该锁，而不会阻塞自己。

---

## **2️⃣ ReentrantLock vs. synchronized**

|**特性**|**ReentrantLock**|**synchronized**|
|---|---|---|
|**锁类型**|显式锁（需要手动加锁 & 解锁）|隐式锁（JVM 自动加锁 & 释放）|
|**是否可重入**|✅ 是|✅ 是|
|**公平锁**|✅ 支持公平 & 非公平|❌ 只能是非公平锁|
|**是否支持尝试获取锁**|✅ `tryLock()` 尝试获取锁|❌ 不支持|
|**是否支持超时**|✅ `tryLock(time, unit)` 可设定超时时间|❌ 不支持|
|**是否支持可中断**|✅ `lockInterruptibly()` 可响应中断|❌ 不支持|
|**性能**|**并发高时性能优于 synchronized**|轻量级，低竞争场景更高效|
|**条件变量支持**|✅ `newCondition()` 支持多个等待队列|❌ 只能使用 `wait()/notify()`|

🔹 **结论**：

- **`synchronized` 适用于简单的同步场景，代码简洁**。
- **`ReentrantLock` 适用于高并发、需要更灵活控制锁的场景**（如超时获取锁、可中断锁）。

---

## **3️⃣ ReentrantLock 关键特性**

### **📌 1. 可重入**

- **同一线程可以多次获取同一把锁**，但必须**释放相同次数**。

### **📌 2. 支持公平锁 & 非公平锁**

- **公平锁**（`new ReentrantLock(true)`）：线程**按队列顺序获取锁**，避免饥饿。
- **非公平锁**（`new ReentrantLock(false)`，默认）：线程**可能“插队”获取锁**，提高吞吐量。

### **📌 3. 支持可中断**

- **`lockInterruptibly()`** 允许等待锁的线程被中断，适用于响应性强的系统。

### **📌 4. 支持超时获取**

- **`tryLock(time, unit)`** 可在**指定时间内尝试获取锁**，超时返回 `false`，避免死锁。

### **📌 5. 支持多个条件变量**

- `newCondition()` **支持多个等待队列**，可以精细控制线程唤醒（比 `wait/notify` 更灵活）。

---

## **4️⃣ 适用场景**

|**场景**|**推荐方式**|
|---|---|
|**简单同步**（低竞争）|`synchronized`|
|**高并发，避免锁饥饿**|`ReentrantLock(true)`（公平锁）|
|**希望尝试获取锁，但不阻塞**|`tryLock()`|
|**希望等待锁，但可被中断**|`lockInterruptibly()`|
|**需要多个条件变量**|`ReentrantLock.newCondition()`|

---

## **5️⃣ 结论**

- **`ReentrantLock` 提供比 `synchronized` 更灵活的锁控制**，适用于高并发场景。
- **支持公平锁、可中断、超时获取、多个条件变量，避免死锁，提高吞吐量**。
- **适用于复杂锁控制，而 `synchronized` 适用于简单同步**。

# 16. `volatile` 关键字

`volatile` 是 Java 中的一个**轻量级同步机制**，用于保证**多线程环境下变量的可见性**和**防止指令重排序**。它适用于**变量的读写操作**，但**不保证原子性**。

---

## **1️⃣ `volatile` 的作用**

### **✅ 1.1 保证可见性**

- **可见性（Visibility）**：当一个线程修改 `volatile` 变量的值，**其他线程立即可见**。
- **普通变量** 在多线程环境下，**一个线程修改的值可能不会立即被其他线程看到**，因为 CPU 可能会对变量进行**缓存**。
- **`volatile` 变量** 直接**写入主内存**，所有线程都会读取**最新的值**。

### **✅ 1.2 防止指令重排序**

- **指令重排序（Instruction Reordering）**：JVM 和 CPU 为了优化性能，可能会**调整指令执行顺序**，但这在多线程环境下可能导致问题。
- **使用 `volatile` 关键字，禁止 JVM 和 CPU 对变量的操作进行重排序**，确保代码按预期执行顺序运行。

---

## **2️⃣ `volatile` 不能保证原子性**

- **`volatile` 只保证变量的读/写可见性，但不保证复合操作的原子性**。
- **比如 `volatile` 不能保证 `count++` 线程安全**，因为 `count++` 实际上是 **三步操作**：
    1. 读取 `count` 的值
    2. `+1` 计算新值
    3. 写回 `count`
- **如果多个线程同时执行 `count++`，可能发生竞态条件（Race Condition），导致丢失更新**。

---

## **3️⃣ `volatile` 的适用场景**

### **✅ 3.1 适用于单一变量的标志位**

- 如 **布尔类型的标志变量（flag）**，用于控制线程退出：
    - **适用于**：`volatile boolean isRunning = true;`
    - **不适用于**：`volatile int counter = 0;`（因为 `counter++` 不是原子操作）

### **✅ 3.2 适用于双重检查锁（DCL）**

- **`volatile` 解决 DCL 可能的指令重排序问题**：
    - 在**单例模式（Singleton）** 中，`volatile` 保证对象初始化的**可见性**，防止未完全初始化的对象被使用。

### **❌ 3.3 不适用于复杂同步**

- **如果一个变量的操作需要确保原子性（如 `count++`）或涉及多个变量，应该使用 `synchronized` 或 `Lock`**。

---

## **4️⃣ `volatile` 和 `synchronized` 的区别**

|特性|`volatile`|`synchronized`|
|---|---|---|
|**作用范围**|变量级别|代码块 / 方法|
|**保证可见性**|✅ 是|✅ 是|
|**保证原子性**|❌ 否|✅ 是|
|**是否阻塞**|❌ 非阻塞|✅ 阻塞|
|**性能开销**|低（适用于轻量级同步）|高（线程竞争会导致上下文切换）|

🚀 **结论**：

- **如果只是保证变量的可见性（如标志位），用 `volatile`**。
- **如果需要保证原子性（如 `i++`），必须用 `synchronized` 或 `Lock`**。

---

## **5️⃣ `volatile` 使用注意事项**

1. **适用于状态标志（flag），如 `volatile boolean stop = false;`**。
2. **不适用于复合操作（如 `++`、累加器、队列操作）**，因为它不保证原子性。
3. **不能代替 `synchronized`，在复杂同步场景下仍需使用锁机制**。
4. **适用于 DCL（双重检查锁单例模式），防止指令重排导致的未初始化问题**。

---

## **6️⃣ 总结**

|作用|`volatile`|
|---|---|
|**保证可见性**|✅ 是|
|**防止指令重排序**|✅ 是|
|**保证原子性**|❌ 否|
|**适用场景**|标志变量、DCL|
|**不适用场景**|计数器、自增、自定义同步逻辑|

🚀 **最佳实践**：

- **需要可见性，不需要原子性 → `volatile`**
- **需要可见性 + 原子性 → `synchronized` 或 `Lock`**

`volatile` 是一种轻量级的同步机制，适用于**状态标志和 DCL 单例模式**，但不能完全替代锁！💡

# 17. HashMap 和 ConcurrentHashMap 的区别

## **1️⃣ 线程安全**

|Map 类型|线程安全性|
|---|---|
|`HashMap`|❌ **非线程安全**，多个线程同时读写时可能发生 **数据不一致** 或 **死循环**|
|`ConcurrentHashMap`|✅ **线程安全**，支持 **并发读写**，不会出现 `HashMap` 的并发问题|

📌 **结论**：

- 在 **单线程或只读场景** 下，`HashMap` 性能更高。
- 在 **多线程并发写入** 时，必须使用 `ConcurrentHashMap`。

---

## **2️⃣ 锁机制**

|Map 类型|锁机制|
|---|---|
|`HashMap`|❌ 无锁，不支持并发写入|
|`ConcurrentHashMap`|✅ **分段锁（Java 7）→ CAS + Synchronized（Java 8）**|

📌 **深入解析**：

- **`HashMap`** 在并发环境下，多个线程可能**同时修改**数据，导致**数据丢失**或**死循环**。
- **`ConcurrentHashMap`（Java 7）** 采用 **"分段锁（Segment Lock）"**，减少锁的粒度，提高并发性能。
- **`ConcurrentHashMap`（Java 8）** 取消了分段锁，改用 **"CAS + `synchronized`"** 提高性能。

---

## **3️⃣ 并发性能**

|Map 类型|并发读|并发写|
|---|---|---|
|`HashMap`|✅ 支持|❌ 线程不安全|
|`ConcurrentHashMap`|✅ 高效|✅ 通过 CAS 和锁机制保障线程安全|

📌 **结论**：

- **多线程同时读取**：两者性能相近。
- **多线程同时写入**：
    - `HashMap` 可能出现**数据丢失**或**异常**。
    - `ConcurrentHashMap` 采用 **分段锁（JDK 7）或 CAS + `synchronized`（JDK 8）**，保证并发安全。

---

## **4️⃣ `null` 作为键值**

|Map 类型|是否支持 `null` 键|是否支持 `null` 值|
|---|---|---|
|`HashMap`|✅ 支持 `null` 键|✅ 支持 `null` 值|
|`ConcurrentHashMap`|❌ **不支持 `null` 键**|❌ **不支持 `null` 值**|

📌 **原因**：

- `ConcurrentHashMap` 设计目标是高并发，`null` 可能会引发 **`NullPointerException`**，因此 **不允许 `null` 键和值**。
- **如果需要 `null`，可以使用 `HashMap` 或 `Collections.synchronizedMap(new HashMap<>())`**。

---

## **5️⃣ 结构变化（JDK 8 之后）**

|Map 类型|JDK 7|JDK 8|
|---|---|---|
|`HashMap`|**数组 + 链表**|**数组 + 链表 + 红黑树（树化优化）**|
|`ConcurrentHashMap`|**Segment 分段锁**|**CAS + `synchronized` + 红黑树**|

📌 **优化点**：

- **`HashMap` 在 JDK 8** 引入了 **红黑树（Red-Black Tree）**，提高性能（避免链表退化为 O(n)）。
- **`ConcurrentHashMap` 在 JDK 8** 取消了 **Segment 分段锁**，改用更高效的 **CAS + `synchronized` + 红黑树** 机制，提高并发性能。

---

## **6️⃣ 适用场景**

|适用场景|选择|
|---|---|
|**单线程环境**|✅ `HashMap`|
|**多线程读多写少**|✅ `ConcurrentHashMap`|
|**高并发写入**|✅ `ConcurrentHashMap`（比 `Collections.synchronizedMap` 效率高）|
|**需要 `null` 键或值**|✅ `HashMap`|

---

## **7️⃣ 总结**

|对比项|`HashMap`|`ConcurrentHashMap`|
|---|---|---|
|**线程安全**|❌ 非线程安全|✅ 线程安全|
|**锁机制**|❌ 无锁|✅ CAS + `synchronized`|
|**并发写**|❌ 可能数据丢失|✅ 高并发支持|
|**`null` 键值**|✅ 允许|❌ 不允许|
|**JDK 7 结构**|**数组 + 链表**|**分段锁 + 数组 + 链表**|
|**JDK 8 结构**|**数组 + 链表 + 红黑树**|**CAS + `synchronized` + 红黑树**|
|**适用场景**|**单线程 / 低并发**|**高并发读写**|

🚀 **最佳实践**

- **单线程环境 → `HashMap`**
- **多线程读多写少 → `ConcurrentHashMap`**
- **高并发写入 → `ConcurrentHashMap`（比 `Collections.synchronizedMap` 更高效）**

# 18. HashMap 添加值的过程

在 `HashMap` 中，`put(K key, V value)` 方法用于**存储键值对**，底层采用 **数组 + 链表 + 红黑树** 的结构进行存储。整个过程可以分为 **计算哈希值、计算索引、插入数据、处理哈希冲突、扩容** 等步骤。

---

## **1️⃣ 计算哈希值**

- `HashMap` 先计算 **Key 的哈希值（hashCode）**，然后对其进行优化，以减少哈希冲突，使哈希值更加均匀分布。

---

## **2️⃣ 计算索引**

- 通过 `hash 值 % 数组长度`（更优化的是 `hash & (length - 1)`）计算**索引位置**，确定数据存放的数组槽位（Bucket）。

---

## **3️⃣ 插入数据**

- **如果计算出的索引位置为空**，则直接存入 `key-value`。
- **如果索引位置已有元素（哈希冲突）**，则使用 **链表** 或 **红黑树** 解决冲突：
    - **JDK 1.7 及以前**：采用**链表**存储（头插法）。
    - **JDK 1.8 及以后**：
        - **如果链表长度 ≤ 8**，仍使用链表存储。
        - **如果链表长度 > 8**，转换为**红黑树**，提高查询性能。

---

## **4️⃣ 处理 Key 重复**

- **如果 Key 已经存在**，则更新原来的 `value`，并返回旧值。
- **如果 Key 不存在**，则插入新节点。

---

## **5️⃣ 触发扩容**

- `HashMap` **默认初始容量为 16，负载因子 0.75**，即当 **元素个数超过 `16 * 0.75 = 12` 时**，会触发**扩容**。
- **扩容方式**：
    1. **数组容量翻倍（变为 2 倍）**。
    2. **重新计算哈希值，重新分配索引位置（rehash）**，减少冲突。

---

## **6️⃣ 过程总结**

1. 计算 `key` 的哈希值 `hashCode`，再通过 `hash` 计算索引 `index`。
2. **如果索引位置为空**，直接插入 `key-value`。
3. **如果索引位置已有数据（哈希冲突）**：
    - **链表长度 ≤ 8**，则使用**链表**存储。
    - **链表长度 > 8**，转换为 **红黑树**。
4. **如果 Key 已存在**，则更新 `value`。
5. **如果元素个数超过阈值（默认 `12`），则触发扩容**。

---

## **7️⃣ 重点优化建议**

|**优化点**|**作用**|
|---|---|
|**合理设置初始容量**|避免频繁扩容，提高性能|
|**减少哈希冲突**|设计良好的 `hashCode()` 方法，均匀分布数据|
|**使用 `LinkedHashMap`**|需要保持插入顺序时|
|**并发场景使用 `ConcurrentHashMap`**|`HashMap` **线程不安全**，高并发使用 **线程安全的 `ConcurrentHashMap`**|

---

### **🔹 结论**

- `HashMap` **先计算哈希值**，然后通过**索引存储**。
- 发生**哈希冲突**时，JDK 1.8 **链表 + 红黑树** 方式存储，提高查询效率。
- **当元素超过阈值时，触发扩容**，进行 **rehash** 重新分配索引。
- `HashMap` **非线程安全**，在并发场景下需使用 `ConcurrentHashMap`。

# 19. ConcurrentHashMap同步机制

在 Java 8 中，`ConcurrentHashMap` 采用了 **CAS（Compare-And-Swap）+ `synchronized`** 结合的方式来保证高并发环境下的线程安全。

这两者结合的设计思路是：

- **优先使用 CAS（无锁操作）来提高性能**，避免线程竞争时的上下文切换。
- **当 CAS 失败时，退而求其次使用 `synchronized` 进行加锁**，确保线程安全。

---

## **1️⃣ 什么是 CAS（Compare-And-Swap）？**

CAS（比较并交换）是一种**乐观锁**机制，在 Java 中由 `Unsafe.compareAndSwapXXX()` 方法提供支持。

**CAS 的基本原理**：

1. **读取变量的当前值（旧值）**。
2. **比较当前值是否等于期望值**：
    - **如果相等**，说明变量没有被其他线程修改，直接更新为新值，操作成功。
    - **如果不相等**，说明变量被其他线程修改过，更新失败，需**重试**。

📌 **特点**：

- **无锁机制**（不涉及操作系统级别的锁，不会引起线程阻塞）。
- **适合高并发环境**（多个线程可以同时尝试更新变量，失败的线程可以自旋重试）。
- **但 CAS 存在 ABA 问题**（可配合 `AtomicStampedReference` 解决）。

---

## **2️⃣ 什么是 `synchronized`？**

`synchronized` 是 Java 提供的**重量级锁**，当 CAS 失败时，`ConcurrentHashMap` 采用 `synchronized` 来**确保安全更新**。

**特点**：

- **保证原子性**：当一个线程持有 `synchronized` 锁时，其他线程必须等待它释放锁后才能执行。
- **适用于复杂同步**：如**需要确保多个操作是原子性的**（如 `ConcurrentHashMap` 需要更新多个节点）。
- **性能较低**（相比 CAS，自旋锁通常更快），但 JDK 1.8 之后优化了锁机制（偏向锁、轻量级锁）。

---

## **3️⃣ 为什么 `ConcurrentHashMap` 采用 CAS + `synchronized`？**

**🔹 目标：提高并发性能，同时保证线程安全**

- **CAS** 适用于 **低竞争场景**，能够快速更新值，提高性能。
- **`synchronized`** 适用于 **高竞争场景**，当 CAS 失败时，采用 **悲观锁** 确保数据一致性。

**🔹 `ConcurrentHashMap` 在 JDK 8 的优化**

- **Java 7**：使用 **分段锁（Segment）**，每个 Segment 是一个 `ReentrantLock`，控制部分桶的并发访问。
- **Java 8**：
    1. **取消分段锁，改用 `Node[]` 数组 + `CAS + synchronized` 机制**。
    2. **通过 CAS 进行无锁操作，尽可能提高并发性能**。
    3. **当 CAS 失败时，采用 `synchronized` 保护链表/红黑树的修改**。

---

## **4️⃣ `CAS + synchronized` 的工作流程**

以 `ConcurrentHashMap.put(key, value)` 为例：

1. **计算索引位置**（`hash(key) % table.length`）。
2. **CAS 插入节点**：
    - 如果目标桶为空，则使用 CAS **尝试插入新节点**。
    - 如果 CAS 成功，插入完成，结束操作。
3. **CAS 失败（桶已被其他线程占用）**：
    - 如果桶中已有链表/红黑树，则加 `synchronized` 锁定该桶，确保并发安全。
    - 在 `synchronized` 代码块内，按 **链表 or 红黑树** 规则插入节点。
4. **桶的元素个数超过阈值**：
    - **转换为红黑树（Treeify）** 以提高查找效率（链表 O(n) → 红黑树 O(log n)）。

---

## **5️⃣ 总结**

|机制|特点|`ConcurrentHashMap` 使用方式|
|---|---|---|
|**CAS（Compare-And-Swap）**|高效无锁，自旋更新|用于 **插入新值 / 更新已有值**|
|**`synchronized`**|线程安全，适合高竞争|当 CAS 失败时，保护链表/红黑树操作|

🚀 **最佳性能设计**：

- **低冲突场景** → **CAS 快速插入/更新**，避免阻塞。
- **高冲突场景** → **`synchronized` 兜底**，确保数据一致性。

JDK 8 通过 **CAS + `synchronized`** 取代了**分段锁**，让 `ConcurrentHashMap` 既具备高并发性能，又能保证线程安全，是高并发场景下的最佳选择！🔥

# 20. 哈希冲突的处理办法

哈希冲突是指 **不同的键（Key）在哈希表中计算出的哈希值相同**，导致它们映射到相同的存储位置（索引）。为了确保哈希表能正确存储和检索数据，需要采用**冲突解决策略**。

---

## **1️⃣ 常见的哈希冲突解决办法**

|方法|方式|适用场景|
|---|---|---|
|**开放地址法（Open Addressing）**|发生冲突时寻找其他空闲位置存放数据|适用于数据量较小、负载因子低的哈希表|
|**链地址法（Chaining）**|使用**链表**或**红黑树**存储相同哈希值的元素|适用于负载因子较高、大规模数据的哈希表|
|**再哈希法（Rehashing）**|计算另一个哈希值，直到找到空位|适用于哈希函数可变的场景|
|**扩容（Resizing & Rehashing）**|增加哈希表大小，重新计算哈希值|适用于负载因子过高时|
|**一致性哈希（Consistent Hashing）**|适用于分布式哈希|适用于分布式存储系统|

---

## **2️⃣ 详细解析不同方法**

### **✅ 2.1 开放地址法（Open Addressing）**

**思路**：如果发生哈希冲突，尝试**寻找其他空闲位置**存放数据。

📌 **常见策略**

1. **线性探测（Linear Probing）**：
    - 按照**固定步长（通常是 1）**寻找下一个可用位置。
    - 问题：容易出现**"堆积"（Clustering）**，影响查找效率。
2. **二次探测（Quadratic Probing）**：
    - 按照**二次方递增**（1², 2², 3²...）寻找可用位置，减少堆积。
3. **双重哈希（Double Hashing）**：
    - 计算两个不同的哈希值 `h1(x)` 和 `h2(x)`，然后 `step = h2(x)`。
    - 寻找空闲位置时，每次跳 `step` 个索引。

📌 **适用场景**

- 适用于**负载因子低（Load Factor < 0.7）**的哈希表。
- 适用于**内存紧张、空间利用率高**的情况。

---

### **✅ 2.2 链地址法（Separate Chaining）**

**思路**：在每个哈希桶（索引位置）中**使用链表存储多个键值对**。

📌 **优化**

- **JDK 8 之后的 `HashMap`**：
    - **链表（Linked List）+ 红黑树（Red-Black Tree）**：
        - 当链表长度超过 `8`，自动转换为**红黑树**（提升查询效率）。
        - 当元素减少到 `6`，红黑树会变回**链表**（减少空间消耗）。

📌 **适用场景**

- **适用于大数据量、负载因子较高（>0.7）** 的场景。
- 适用于**哈希值分布均匀**的情况。

---

### **✅ 2.3 再哈希法（Rehashing）**

**思路**：当发生冲突时，使用**另一个哈希函数**计算新的索引位置。

📌 **常见方式**

- `h1(key) = key % tableSize`
- `h2(key) = 7 - (key % 7)`（选择一个质数 7 作为二次哈希）

📌 **适用场景**

- 适用于 **哈希函数可变的场景**（如动态哈希）。
- 适用于 **不希望额外使用链表存储冲突数据的情况**。

---

### **✅ 2.4 扩容（Resizing & Rehashing）**

**思路**：当哈希表负载因子超过一定阈值（如 `0.75`），扩展哈希表，并**重新计算所有元素的哈希值**。

📌 **JDK 8 中 `HashMap` 规则**

- 默认大小：`16`
- 负载因子（Load Factor）：`0.75`
- **扩容方式**：当 `size > 0.75 * capacity` 时，**容量翻倍**，重新计算所有哈希值。

📌 **适用场景**

- 适用于 **需要长期存储大量数据的哈希表**。

---

### **✅ 2.5 一致性哈希（Consistent Hashing）**

**思路**：在**分布式系统**中，使用环形哈希空间（0 ~ 2³²）减少数据迁移。

📌 **应用**

- **分布式缓存（如 Redis 集群）**
- **分布式存储（如 Cassandra、DynamoDB）**
- **负载均衡**

📌 **适用场景**

- 适用于 **分布式环境**，减少节点增删导致的数据重分布问题。

---

## **3️⃣ 哈希冲突处理方法对比**

| 方法        | 处理方式         | 空间开销 | 查询性能               | 适用场景       |
| --------- | ------------ | ---- | ------------------ | ---------- |
| **开放地址法** | 线性/二次/双重探测   | 低    | 适中                 | 负载因子低，空间受限 |
| **链地址法**  | 链表或红黑树存储冲突元素 | 高    | 高（O(1) 或 O(log n)） | 负载因子高，大数据量 |
| **再哈希法**  | 计算多个哈希值      | 低    | 适中                 | 适用于哈希可变场景  |
| **扩容**    | 扩大哈希表并重新哈希   | 高    | 高（扩容后）             | 长期存储大量数据   |
| **一致性哈希** | 哈希环存储数据      | 适中   | 高                  | 分布式存储、缓存   |

---

## **4️⃣ 总结**

📌 **最佳选择**

- **小数据量 & 负载因子低** → **开放地址法**
- **大数据量 & 负载因子高** → **链地址法（JDK 8: 红黑树优化）**
- **分布式存储/缓存** → **一致性哈希**
- **长期存储大量数据** → **扩容 & 再哈希**

# 21. 线程池的类型

## **1️⃣ `ThreadPoolExecutor` 线程池架构**

所有线程池都基于 `ThreadPoolExecutor` 进行封装，其核心参数：

- **核心线程数（corePoolSize）**：线程池中**最少保留的线程数**，即使它们空闲也不会被销毁。
- **最大线程数（maximumPoolSize）**：线程池中**允许的最大线程数**，超出任务队列时会新建线程，直到达到该值。
- **任务队列（workQueue）**：用于存放等待执行的任务。
- **线程存活时间（keepAliveTime）**：超出 `corePoolSize` 的空闲线程，在超过此时间后会被回收。
- **拒绝策略（RejectedExecutionHandler）**：线程池满了，任务无法提交时的处理策略。
- **存活时间的单位（unit）**：`keepAliveTime` 的时间单位，如 `TimeUnit.SECONDS`、`TimeUnit.MILLISECONDS` 等。
- **线程工厂（threadFactory）**用于创建线程的工厂，允许自定义线程的名称、优先级等，默认是 `Executors.defaultThreadFactory()`。

---

## **2️⃣ Java 提供的线程池类型**

|**线程池类型**|**特点**|**适用场景**|
|---|---|---|
|**固定大小线程池（FixedThreadPool）**|**核心线程数固定**，任务超出时进入队列|CPU 密集型任务，控制线程数防止资源耗尽|
|**缓存线程池（CachedThreadPool）**|**无核心线程，线程数可动态调整**|短时间需要大量线程，任务执行快（如突发流量）|
|**单线程线程池（SingleThreadExecutor）**|**单个线程执行任务**，保证任务顺序|串行执行任务，适用于日志、顺序执行任务|
|**定时任务线程池（ScheduledThreadPool）**|**支持定时任务和周期性任务**|需要定时执行的任务，如定期检查、定时任务|

---

### **✅ 2.1 `FixedThreadPool`（固定大小线程池）**

- 线程数量固定，超出任务会进入**阻塞队列**，避免线程过多导致资源耗尽。
- **适用于 CPU 密集型任务**，如并行计算、批量任务处理。

📌 **场景示例**

- 服务器处理固定数量的客户端请求
- 并发数据库查询

---

### **✅ 2.2 `CachedThreadPool`（缓存线程池）**

- **无核心线程**，最大线程数**几乎无限制**（`Integer.MAX_VALUE`）。
- **适用于 IO 密集型任务**，需要大量短期线程（如 Web 服务器处理请求）。
- 如果线程**空闲 60 秒**，则被销毁，避免资源浪费。

📌 **场景示例**

- **高并发 Web 服务器**
- **短时间大量任务，如爬虫**

---

### **✅ 2.3 `SingleThreadExecutor`（单线程线程池）**

- **只有一个线程**，所有任务按照**提交顺序（FIFO, LIFO, 优先级）**执行。
- **适用于任务需要严格按顺序执行的场景**，如日志记录、事务处理。

📌 **场景示例**

- **日志系统**（按时间顺序记录日志）
- **订单处理**（保证订单的顺序执行）

---

### **✅ 2.4 `ScheduledThreadPool`（定时任务线程池）**

- 适用于 **延迟任务** 或 **周期性任务**。
- 线程数可指定，适合**定时调度任务**（如心跳检测、定时任务）。

📌 **场景示例**

- **定时任务（如定期备份数据库）**
- **心跳检测（如服务器健康检查）**
- **定时邮件发送**

---

## **3️⃣ 线程池类型对比**

|线程池类型|线程数量|任务队列|适用场景|
|---|---|---|---|
|**FixedThreadPool**|固定大小|阻塞队列|**CPU 密集型任务**（如并行计算）|
|**CachedThreadPool**|动态扩展|SynchronousQueue（无队列）|**IO 密集型任务**（如爬虫、大量短期任务）|
|**SingleThreadExecutor**|1 个线程|无界队列|**任务需顺序执行**（如日志、订单处理）|
|**ScheduledThreadPool**|固定大小|延时队列|**定时任务、周期性任务**|

---

## **4️⃣ 线程池的选择**

🚀 **如何选择合适的线程池？**

1. **CPU 密集型任务**（如计算、压缩） → `FixedThreadPool`
2. **IO 密集型任务**（如数据库查询、网络请求） → `CachedThreadPool`
3. **任务需要严格顺序执行**（如日志） → `SingleThreadExecutor`
4. **定时任务**（如心跳检测、定时备份） → `ScheduledThreadPool`

# 22. 线程池的拒绝策略

当线程池 **任务队列已满**，且**线程数量达到最大值**时，提交的新任务会被**拒绝执行**。此时，`ThreadPoolExecutor` 提供了 **4 种默认的拒绝策略**，可通过 `setRejectedExecutionHandler()` 自定义策略。

---

## **1️⃣ 4 种默认拒绝策略**

|拒绝策略|触发条件|处理方式|适用场景|
|---|---|---|---|
|**AbortPolicy（默认）**|任务无法提交时|**抛出 `RejectedExecutionException`**|需要保证任务不能丢失|
|**CallerRunsPolicy**|任务无法提交时|**由调用线程（提交任务的线程）直接执行任务**|降低提交速率，避免任务丢失|
|**DiscardPolicy**|任务无法提交时|**直接丢弃任务，不抛异常**|允许丢失部分任务，适用于不重要任务|
|**DiscardOldestPolicy**|任务无法提交时|**丢弃队列中最旧的任务，然后尝试重新提交新任务**|适用于需要优先处理最新任务的场景|

---

## **2️⃣ 详细解析**

### **✅ 2.1 `AbortPolicy`（默认策略）**

- **默认策略**，任务无法提交时，**直接抛异常** `RejectedExecutionException`，防止系统继续提交任务。
- **适用于：** 任务必须执行，不能丢失，适用于**关键业务**（如金融交易）。

📌 **缺点**

- 可能导致**程序崩溃**，需要用 `try-catch` 捕获异常并处理。

---

### **✅ 2.2 `CallerRunsPolicy`（调用者执行策略）**

- **新任务由提交任务的线程（调用线程）执行**，而不是线程池中的线程。
- **适用于：** 让主线程分担工作，**缓解线程池压力**，但可能导致主线程变慢。

📌 **缺点**

- 任务多时，主线程可能会被大量任务阻塞，影响正常运行。

---

### **✅ 2.3 `DiscardPolicy`（丢弃策略）**

- **直接丢弃新任务，不抛异常**，适用于允许丢失部分任务的场景（如日志处理）。
- **适用于：** **低优先级任务**，如**临时缓存、日志记录**。

📌 **缺点**

- 任务丢失后不可恢复，无法保证所有任务都被执行。

---

### **✅ 2.4 `DiscardOldestPolicy`（丢弃最老任务策略）**

- **丢弃队列中最早进入的任务，然后尝试执行新任务**。
- **适用于：** 需要**保证最新任务优先执行**的场景，如 **最新日志、最新消息处理**。

📌 **缺点**

- 可能导致重要任务被丢弃，需要确保业务逻辑允许这样做。

---

## **3️⃣ 选择合适的拒绝策略**

|业务场景|推荐策略|适用原因|
|---|---|---|
|**任务必须全部执行（如订单、支付）**|`AbortPolicy`|遇到问题直接抛异常，防止任务丢失|
|**允许部分任务丢失（如日志处理）**|`DiscardPolicy`|直接丢弃任务，避免影响主业务|
|**新任务优先级高（如最新消息）**|`DiscardOldestPolicy`|丢弃最老任务，优先处理最新任务|
|**流量高峰时平稳处理（如限流降级）**|`CallerRunsPolicy`|让主线程执行任务，降低提交速率|

🚀 **推荐策略**

- **核心业务（如金融、订单）** → `AbortPolicy`
- **可丢任务（如日志、缓存）** → `DiscardPolicy`
- **保证最新任务（如消息处理）** → `DiscardOldestPolicy`
- **降低系统压力（如限流）** → `CallerRunsPolicy`

# 23. 线程池的工作流程

## **1️⃣ 线程池的执行流程**

当一个任务提交到线程池时，`ThreadPoolExecutor` 按以下步骤处理：

### **🔹 1. 判断核心线程是否有空闲**

- **如果有空闲核心线程**，则直接交给核心线程执行任务。
- **如果没有空闲核心线程**，则进入**下一步**。

### **🔹 2. 任务进入等待队列**

- 任务被放入**任务队列（workQueue）**，等待空闲的核心线程执行。
- **如果队列未满**，任务会在队列中等待执行。
- **如果队列已满**，则进入**下一步**。

### **🔹 3. 判断是否可以创建非核心线程**

- **如果当前线程数小于 `maximumPoolSize`（最大线程数）**，则创建**新的非核心线程**来执行任务。
- **如果线程数已达最大值**，则进入**下一步**。

### **🔹 4. 执行拒绝策略**

- 当**核心线程 + 非核心线程已满**，且**任务队列已满**，则**执行拒绝策略（RejectedExecutionHandler）**。
- 拒绝策略包括：
    - **`AbortPolicy`**（默认）：抛出 `RejectedExecutionException`，防止系统崩溃。
    - **`CallerRunsPolicy`**：由调用线程直接执行任务，降低提交速率。
    - **`DiscardPolicy`**：直接丢弃新任务，不抛异常。
    - **`DiscardOldestPolicy`**：丢弃最早等待的任务，再尝试提交新任务。

### **🔹 5. 任务执行完毕后，线程如何处理**

- **核心线程（corePoolSize 内的线程）**：默认**不会销毁**，可复用。
- **非核心线程（超过 corePoolSize 的线程）**：
    - **空闲时间超过 `keepAliveTime`**，线程会被销毁，避免资源浪费。
    - **如果 `allowCoreThreadTimeOut=true`**，则核心线程也可销毁。

---


## **2️⃣ 线程池的核心参数与流程影响**

| **参数**                     | **影响线程池行为**                                   |
| -------------------------- | --------------------------------------------- |
| `corePoolSize`             | 线程池中的**核心线程数**，优先使用这部分线程处理任务                  |
| `maximumPoolSize`          | 线程池中**最大线程数**，超过 `corePoolSize` 且队列已满时，会创建新线程 |
| `workQueue`                | 任务队列，决定**如何存放等待执行的任务**                        |
| `keepAliveTime`            | 超过 `corePoolSize` 的**空闲线程存活时间**，到期销毁          |
| `RejectedExecutionHandler` | 任务被拒绝执行时的**处理策略**                             |

---

## **3️⃣ 任务队列（`workQueue`）的作用**

任务队列用于**缓冲任务**，影响线程池行为：

|任务队列|作用|适用场景|
|---|---|---|
|**有界队列（`LinkedBlockingQueue`）**|适用于**固定大小线程池**，避免无限增长|**适用于生产环境**，防止 OOM|
|**无界队列（`SynchronousQueue`）**|不存储任务，直接交给线程执行|**适用于高吞吐量、动态线程创建**|
|**优先级队列（`PriorityBlockingQueue`）**|任务按照**优先级**执行|**适用于定时任务、调度任务**|

---

## **4️⃣ 线程池的生命周期**

|**状态**|**描述**|
|---|---|
|**RUNNING**|线程池**正常运行**，接受任务并执行|
|**SHUTDOWN**|**调用 `shutdown()`**，不再接受新任务，但会执行完队列中的任务|
|**STOP**|**调用 `shutdownNow()`**，尝试**中断所有线程**，丢弃任务|
|**TIDYING**|所有任务完成，线程池正在清理|
|**TERMINATED**|线程池彻底终止|

---

## **5️⃣ 线程池工作流程总结**

|**阶段**|**工作内容**|
|---|---|
|**任务提交**|任务提交到线程池|
|**核心线程执行**|先使用 `corePoolSize` 线程执行|
|**任务进入队列**|核心线程已满，任务进入队列|
|**创建新线程**|队列已满，创建新线程（不超过 `maximumPoolSize`）|
|**拒绝策略触发**|线程池满了，执行 `RejectedExecutionHandler`|
|**任务执行完毕**|线程回收，非核心线程空闲超时后销毁|

# 24. JVM 内存模型

## **1️⃣ JVM 内存模型的组成**

JVM 运行时主要管理两类内存：

- **线程共享内存**（所有线程可访问）
- **线程私有内存**（每个线程独立拥有）

---

### **🔹 1.1 线程共享内存**

✅ **所有线程共享的数据（存储在堆中）**

| **区域**               | **作用**                      |
| -------------------- | --------------------------- |
| **堆（Heap）**          | **存放对象实例**，所有线程共享           |
| **方法区（Method Area）** | **存储类元信息**（类结构、静态变量、运行时常量池） |

---

### **🔹 1.2 线程私有内存**

✅ **每个线程独立拥有的内存（不共享）**

|**区域**|**作用**|
|---|---|
|**程序计数器（PC Register）**|记录当前线程执行的**字节码指令**|
|**虚拟机栈（JVM Stack）**|线程执行方法时的**栈帧存储区域**（局部变量、方法调用信息）|
|**本地方法栈（Native Method Stack）**|存储**Native 方法**的执行信息|

---

## **3️⃣ JVM 运行时数据区域详细解析**

### **✅ 3.1 堆（Heap）**

- **存放对象实例**（几乎所有对象都在堆上分配）。
- **线程共享**，所有线程都能访问。
- 垃圾回收（GC）主要作用于**堆内存**。

📌 **堆内存分区**

- **新生代（Young Generation）**
    - **Eden 区**（对象刚创建时进入此区）。
    - **Survivor 0/1 区**（对象经历几次 GC 后仍存活会进入）。
- **老年代（Old Generation）**
    - 经过多次 GC 仍存活的对象，会晋升到老年代。

---

### **✅ 3.2 方法区（Method Area，JDK 8+ 使用 Metaspace）**

- 存储**类的元信息**（类名、字段、方法、静态变量等）。
- 线程共享，**在 JDK 8 之后移到了本地内存**（不在堆中）。

📌 **存储内容**

- 类的结构信息（类的字段、方法、访问权限）。
- 运行时常量池（字符串常量池、方法引用）。
- 静态变量（`static` 变量）。
- 方法字节码。

---

### **✅ 3.3 JVM 栈（Java Virtual Machine Stack）**

- 每个线程独立拥有 **"栈帧"（Stack Frame）**，用于存储**方法调用信息**。
- **存储局部变量、操作数栈、方法返回地址**。
- **方法执行时**，会创建一个新的栈帧，方法执行完成后，栈帧会**出栈**。

---

### **✅ 3.4 PC 寄存器（Program Counter Register）**

- 记录 **当前线程执行的字节码指令地址**。
- **每个线程都有自己的 PC 寄存器**，线程切换时可以恢复执行位置。
- **Native 方法的 PC 寄存器值为 `undefined`**（本地方法在 CPU 执行）。

---

### **✅ 3.5 本地方法栈（Native Method Stack）**

- 专门用于**执行 Native 方法**（非 Java 代码，如 C 代码）。
- 调用 `JNI`（Java Native Interface）方法时使用。

---

## **4️⃣ Java 内存模型（JMM）和线程之间的关系**

JMM 规定：

- **每个线程有自己的** **"工作内存"（Thread Working Memory）**（存储变量的本地副本）。
- 线程对变量的修改必须**先更新到主内存**（Heap），其他线程才能读取最新的值。

📌 **解决可见性问题**

| 关键字            | 作用                  |
| -------------- | ------------------- |
| `volatile`     | 保证变量**可见性**，防止指令重排序 |
| `synchronized` | 保证**原子性、可见性、有序性**   |
| `final`        | 线程安全的不可变数据          |

---

## **5️⃣ JVM 内存模型总结**

| **内存区域**           | **是否共享** | **存储内容**     |
| ------------------ | -------- | ------------ |
| **堆（Heap）**        | 线程共享     | 对象实例         |
| **方法区（MetaSpace）** | 线程共享     | 类信息、静态变量、常量池 |
| **运行时常量池**         | 线程共享     | 字符串常量、方法引用   |
| **JVM 栈（Stack）**   | 线程私有     | 方法调用、局部变量    |
| **PC 寄存器**         | 线程私有     | 当前执行的字节码地址   |
| **本地方法栈**          | 线程私有     | 调用 Native 方法 |

# 25. 堆内存模型划分

### **堆内存模型划分（Java Heap Memory Structure）**

Java **堆（Heap）** 是 JVM 内存的最大区域，**用于存放所有对象实例和数组**，所有线程共享堆内存。堆内存**主要用于垃圾回收（GC），因此 JVM 采用了不同的区域划分和回收策略来优化性能。**

---

## **1️⃣ 堆内存的划分**

Java 堆主要分为 **年轻代（Young Generation）** 和 **老年代（Old Generation）**，JDK 8 之前还包括 **永久代（PermGen），JDK 8 之后替换为元空间（Metaspace）**。

---

## **2️⃣ 堆内存详细划分**

### **✅ 2.1 年轻代（Young Generation）**

**特点：**

- **存放新创建的对象**，对象生命周期短。
- **GC 频率高**，主要使用 **Minor GC**（垃圾回收较快）。
- 80% ~ 90% 的对象**在年轻代创建，也在年轻代被回收**。

**内部结构：**

|**区域**|**比例**|**作用**|
|---|---|---|
|**Eden 区**|**8**|**新对象分配区**（几乎所有对象创建在 Eden）|
|**Survivor 0（S0）**|**1**|**存活对象的交换区**|
|**Survivor 1（S1）**|**1**|**与 S0 交换位置**|

📌 **对象的生命周期**

1. **新对象** 创建时进入 **Eden 区**。
2. **第一次 GC（Minor GC）**：
    - 存活的对象进入 **Survivor 0（S0）**，其余对象被清理。
3. **后续 GC**：
    - S0 存活的对象进入 **S1**，S0 被清空。
    - S1 存活的对象进入 **S0**，S1 被清空。
    - **多次 GC 仍存活的对象晋升到老年代（Old Generation）**。

---

### **✅ 2.2 老年代（Old Generation）**

**特点：**

- **存放长生命周期的对象**（如缓存、单例模式对象）。
- **GC 频率低**，但**回收耗时较长**，使用 **Major GC（Full GC）**。
- **新生代经过多次 GC 仍存活的对象，会晋升到老年代**。

📌 **晋升条件**

- **对象在 Survivor 经过 `MaxTenuringThreshold` 次 GC**（默认 `15`）仍存活，则进入老年代。
- **大对象直接进入老年代**（如大数组，避免 Survivor 频繁复制）。

---

### **✅ 2.3 元空间（Metaspace，JDK 8+）**

**特点：**

- JDK 8 之后，**元数据从堆内存（PermGen）移到了本地内存**，称为 **元空间（Metaspace）**。
- **存储类元信息**（类结构、方法、静态变量、运行时常量池）。
- **默认大小可动态调整**（不会导致 `OutOfMemoryError: PermGen`）。

📌 **元空间 vs 永久代**

|**版本**|**永久代（PermGen，JDK 7 及以前）**|**元空间（Metaspace，JDK 8+）**|
|---|---|---|
|**存储内容**|类信息、方法、常量池、静态变量|类信息、方法、常量池、静态变量|
|**所在内存**|**JVM 堆内存**|**本地内存（Native Memory）**|
|**OOM 错误**|`OutOfMemoryError: PermGen`|`OutOfMemoryError: Metaspace`|

---

## **3️⃣ 垃圾回收（GC）策略**

JVM 采用不同的垃圾回收策略，提高 GC 效率：

|**代**|**GC 类型**|**触发条件**|**清理范围**|
|---|---|---|---|
|**年轻代**|**Minor GC**|Eden 区满|**清理 Eden + 复制 Survivor**|
|**老年代**|**Major GC / Full GC**|老年代满|**清理整个堆（Young + Old）**|

📌 **GC 触发条件**

1. **Eden 区满 → 触发 Minor GC**（存活对象进入 Survivor）。
2. **Survivor 交换区满 → 晋升老年代**。
3. **老年代满 → 触发 Full GC**（暂停所有线程，影响性能）。

---

## **4️⃣ 堆内存调优**

🚀 **常见 JVM 参数**

|参数|作用|
|---|---|
|`-Xms<size>`|**初始堆大小**（默认 1/64 物理内存）|
|`-Xmx<size>`|**最大堆大小**（默认 1/4 物理内存）|
|`-XX:NewRatio=n`|**新生代和老年代比例**（默认 `1:2`）|
|`-XX:SurvivorRatio=n`|**Eden:Survivor 比例**（默认 `8:1:1`）|
|`-XX:+UseG1GC`|**启用 G1 垃圾回收器（JDK 9+ 推荐）**|
|`-XX:MaxMetaspaceSize=<size>`|**限制 Metaspace 大小**|

📌 **优化策略**

- **大对象直接进老年代**：`-XX:PretenureSizeThreshold`
- **增加 Eden 区，减少 Minor GC**：调整 `-XX:NewRatio`
- **避免 Full GC 过多**：合理分配 `-Xmx`、`-Xms`

---

## **5️⃣ 总结**

|**区域**|**存储内容**|**GC 触发**|**特点**|
|---|---|---|---|
|**Eden（新生代）**|新创建对象|Eden 满|频繁 GC，存活对象进入 Survivor|
|**Survivor（新生代）**|经过多次 GC 仍存活的对象|Survivor 满|S0 <-> S1 交换，超过 `15` 次晋升老年代|
|**老年代**|长生命周期对象|老年代满|GC 频率低，Full GC 耗时长|
|**元空间（JDK 8+）**|类元信息、静态变量|类加载过多|使用本地内存，不在堆|

# 26. `new` 一个对象在 JVM 内存模型中的存放情况

在 Java 中，使用 `new` 关键字创建对象时，JVM 需要在**内存模型**中进行一系列操作，包括**分配内存、初始化对象、返回引用**等。对象的不同部分会存放在不同的内存区域。

---

## **1️⃣ `new` 关键字创建对象的步骤**

当执行：

~~~
Person p = new Person();
~~~

JVM 主要执行以下步骤：

1. **检查类元信息（Method Area / Metaspace）**
    
    - JVM 先检查 `Person` 类是否已经加载（在 **方法区/元空间**）。
    - 如果类未加载，则**通过类加载器加载类信息**。
2. **在堆（Heap）中分配内存**
    
    - 在**堆**（Heap）中**分配对象内存**。
    - 可能使用 **指针碰撞（Bump-the-pointer）** 或 **空闲列表（Free-list）** 方式分配内存。
3. **初始化对象（构造方法 & 默认值）**
    
    - **对象头**（哈希码、GC 信息、类指针）被初始化。
    - **成员变量设默认值**（`0`、`false`、`null`）。
    - **执行构造方法**，初始化实例变量。
4. **返回对象引用**
    
    - 堆内存中的对象地址存放到**栈（Stack）中的局部变量表**。
    - `p` 存储的是对象的**引用地址**，实际对象存放在**堆**。

---

## **2️⃣ `new` 对象在 JVM 内存模型的存放**

|**内存区域**|**存储内容**|
|---|---|
|**方法区（JDK 8+ 元空间）**|`Person` 类的**元信息**（类名、方法、字段、静态变量）|
|**堆（Heap）**|**对象实例**（对象头 + 实例变量）|
|**JVM 栈（Stack）**|变量 `p` 存储的是对象的**引用地址**|
|**程序计数器（PC Register）**|记录 `new Person();` 指令执行的位置|

---

## **3️⃣ 具体存储位置**

~~~
public class Person { 
	private String name = "Alice"; // 成员变量（对象的一部分，存放在堆） 
	private static int age = 30; // 静态变量（存放在方法区/元空间） 
	public Person() { } // 构造方法（存放在方法区）
}
~~~

📌 **存储情况**

|**变量类型**|**存储位置**|**存储内容**|
|---|---|---|
|**对象实例 (`new Person()`)**|**堆（Heap）**|**`name`（成员变量），对象头**|
|**对象引用 (`p`)**|**JVM 栈（Stack）**|指向堆内存的地址|
|**类元信息 (`Person` 类结构)**|**方法区 / 元空间**|`Person` 类的方法、字段描述|
|**静态变量 (`age`)**|**方法区 / 元空间**|`static int age`|

---

## **4️⃣ `new` 对象的优化**

### **✅ 4.1 栈上分配（逃逸分析）**

- **如果对象作用域很小（方法内部创建，不被外部引用），JVM 可能直接在栈上分配，避免 GC**。
    
    **JVM 可能优化为：**
    - 直接在**JVM 栈**上分配 `p`，对象**不进入堆**，方法结束后直接销毁。

---

### **✅ 4.2 线程本地存储（TLAB，Thread Local Allocation Buffer）**

- JVM **为每个线程分配一块私有的堆空间（TLAB）**，避免多线程竞争堆内存。
- **小对象优先分配在 TLAB**，减少锁竞争，提高性能。

---

### **✅ 4.3 大对象直接进入老年代**

- **大对象（如长数组、字符串）直接进入老年代（Old Generation）**，避免 Survivor 频繁复制。

---

## **5️⃣ 总结**

✅ **方法区（元空间）** 存储类信息、静态变量。  
✅ **堆（Heap）** 存储**对象实例**（成员变量、对象头）。  
✅ **栈（Stack）** 存储**对象引用**（指向堆内存的地址）。  
✅ **JVM 优化：TLAB、栈上分配、逃逸分析** 提高性能。

# 27. 类加载（Class Loading）存放位置

Java **类加载（Class Loading）** 是 JVM 在运行时**动态加载 `.class` 文件**的过程。类的元信息会存放在**方法区（JDK 8+ 为元空间 Metaspace）**。

---

## **1️⃣ 类加载的存放位置**

|**存储区域**|**存储内容**|
|---|---|
|**方法区（JDK 8+ 为元空间 Metaspace）**|**类的元信息**（类名、方法、字段、常量池、静态变量等）|
|**堆（Heap）**|**对象实例**（`new` 创建的对象）|
|**栈（Stack）**|**对象引用、方法调用信息**|

📌 **注意**

- **JDK 7 及以前**，类的元信息存放在**方法区（PermGen 永久代）**。
- **JDK 8+ 以后**，永久代被**元空间（Metaspace）** 取代，存储在**本地内存（Native Memory）**。

---

## **2️⃣ 类加载存放的内容**

当一个类被加载，JVM 会将以下信息存储在 **方法区（Metaspace）**：

|**存储内容**|**说明**|
|---|---|
|**类的基本信息**|类名、修饰符、父类、接口等|
|**运行时常量池**|字符串常量、方法引用、字段符号引用|
|**字段信息**|成员变量、类型、修饰符|
|**方法信息**|方法名、参数、返回值、字节码|
|**静态变量（static）**|类级别变量，存储在方法区|
|**类的初始化信息**|`<clinit>()` 静态代码块|

---

## **3️⃣ 类加载的过程**

📌 **类的加载分为以下步骤**

1. **加载（Loading）**
    
    - **查找 `.class` 文件**，读取字节码，存入**方法区（Metaspace）**。
    - **创建运行时常量池**（存放字符串、方法引用等）。
    - **分配内存空间**（但不会执行初始化）。
2. **连接（Linking）**
    
    - **验证（Verification）**：检查字节码格式、类型安全等。
    - **准备（Preparation）**：给 `static` 变量**分配默认值**。
    - **解析（Resolution）**：解析符号引用（方法、字段）为**直接引用**。
3. **初始化（Initialization）**
    
    - 执行 **静态变量赋值**，调用 `<clinit>()` 静态代码块。

---

## **4️⃣ 示例**


📌 **存储情况**

|**存储区域**|**存储内容**|
|---|---|
|**方法区（Metaspace）**|`Person` 的**类信息**（字段、方法）、`static String type`|
|**堆（Heap）**|`new Person("Alice")` 创建的对象|
|**栈（Stack）**|`Person p = new Person();` 变量 `p` 存储的是对象引用|

---

## **5️⃣ 为什么 JDK 8 用 Metaspace 代替永久代（PermGen）？**

|**对比项**|**永久代（PermGen，JDK 7 及以前）**|**元空间（Metaspace，JDK 8+）**|
|---|---|---|
|**存储位置**|JVM **堆内存**|**本地内存（Native Memory）**|
|**OOM 问题**|`OutOfMemoryError: PermGen space`|`OutOfMemoryError: Metaspace`（可动态扩展）|
|**GC 影响**|类卸载依赖 GC，频繁 Full GC|本地内存管理，减少 GC 影响|

🚀 **JDK 8 的 Metaspace 不受堆内存限制，避免了 `PermGen OOM` 问题，提高了 JVM 性能！** 💡

# 28. 垃圾回收

## **1️⃣ GC 触发条件**

JVM 什么时候触发 GC？

1. **年轻代（Young Generation）Eden 区满时** → 触发 **Minor GC**。
2. **老年代（Old Generation）空间不足时** → 触发 **Major GC / Full GC**。
3. **显式调用 `System.gc()`**（通常不推荐）。

---

## **2️⃣ GC 分类**

Java 主要有两类 GC：

|GC 类型|触发条件|作用范围|
|---|---|---|
|**Minor GC（新生代 GC）**|Eden 区满|仅清理**年轻代**（存活对象移至 Survivor）|
|**Major GC（老年代 GC）**|老年代空间不足|清理**老年代**，通常伴随 Full GC|
|**Full GC（全局 GC）**|触发 `System.gc()` 或 Metaspace 满|清理**整个堆（Young + Old）**，代价高|

---

## **3️⃣ 常见 GC 算法**

|**GC 算法**|**特点**|**适用区域**|
|---|---|---|
|**引用计数（Reference Counting）**|每个对象维护引用计数，计数为 0 时回收|早期方法，存在**循环引用问题**|
|**标记-清除（Mark-Sweep）**|**标记存活对象 → 清除未被引用的对象**|**老年代 GC**，容易产生碎片|
|**标记-整理（Mark-Compact）**|**标记存活对象 → 移动存活对象 → 清理无用对象**|**老年代 GC**，减少碎片|
|**复制算法（Copying）**|**对象分区（Eden + Survivor），存活对象复制到 Survivor**|**年轻代（Minor GC）**|
|**分代收集（Generational GC）**|**不同对象生命周期采用不同回收策略**|现代 JVM **默认策略**|

---

## **4️⃣ JVM 垃圾回收器（GC Collectors）**

JVM 提供了**不同的垃圾回收器**，适用于不同的应用场景。

### **✅ 4.1 串行垃圾回收器（Serial GC）**

| **特点** | **单线程**，适用于**小内存应用** | | **适用场景** | 适合单核 CPU、小型应用（如 **桌面应用、嵌入式系统**） | | **JVM 参数** | `-XX:+UseSerialGC` |

📌 **工作方式**

- **Stop-the-world（STW）**：暂停所有线程进行 GC。
- **使用** 复制算法（年轻代）、标记-整理（老年代）。

---

### **✅ 4.2 并行垃圾回收器（Parallel GC）**

| **特点** | **多线程并行 GC**，提高吞吐量 | | **适用场景** | 高吞吐应用，如 **批量计算、后台任务** | | **JVM 参数** | `-XX:+UseParallelGC` |

📌 **工作方式**

- **年轻代**：多线程并行 **Minor GC**（复制算法）。
- **老年代**：**多线程 Major GC**（标记-整理）。

---

### **✅ 4.3 CMS（Concurrent Mark-Sweep）**

| **特点** | **低延迟**，减少 Stop-the-world 时间 | | **适用场景** | 适合**低延迟应用**（如 **Web 服务器**） | | **JVM 参数** | `-XX:+UseConcMarkSweepGC` |

📌 **工作方式**

1. **初始标记（STW）** → 标记 GC Roots 直接可达对象。
2. **并发标记**（线程可继续工作）。
3. **重新标记（STW）** → 处理并发阶段新增的对象。
4. **并发清除**（线程可继续工作）。

🚀 **缺点**

- **容易产生内存碎片**（老年代）。
- **高 CPU 开销**，GC 线程和业务线程同时执行。

---

### **✅ 4.4 G1（Garbage First，JDK 9+ 默认 GC）**

| **特点** | **区域化分代收集，减少 STW 时间** | | **适用场景** | 适用于**大内存应用（4GB+）** | | **JVM 参数** | `-XX:+UseG1GC` |

📌 **G1 关键点**

- **分区回收（Region-based）**：堆被划分为多个**Region**，不区分年轻代、老年代。
- **混合回收（Mixed GC）**：同时清理年轻代 + 老年代，避免 Full GC。
- **预测停顿时间**：可以设置 `-XX:MaxGCPauseMillis=<ms>` 控制最大停顿时间。

🚀 **优点**

- **减少 Full GC 发生频率**。
- **适合大内存应用（Web 服务器、大型数据分析）**。

---

### **✅ 4.5 ZGC（JDK 11+，超低延迟 GC）**

| **特点** | **超低 STW 时间（<10ms）**，适用于**大内存（100GB+）** | | **适用场景** | **超大规模内存应用（金融、高并发系统）** | | **JVM 参数** | `-XX:+UseZGC` |

📌 **ZGC 关键点**

- **几乎所有 GC 过程都是并发的**（不会长时间暂停线程）。
- **Region-based** 但支持动态扩展（最大 16TB 内存）。
- **适合大规模数据集、高吞吐应用**。

🚀 **优点**

- **GC 停顿时间不随堆大小增加**（即使 1TB 内存，STW 仍 <10ms）。
- **几乎无 Full GC**。

---

## **5️⃣ GC 选择指南**

|**应用类型**|**推荐 GC**|**JVM 参数**|
|---|---|---|
|**小型应用 / 桌面程序**|**Serial GC**|`-XX:+UseSerialGC`|
|**高吞吐批量计算（大数据）**|**Parallel GC**|`-XX:+UseParallelGC`|
|**低延迟 Web 服务器**|**CMS GC / G1 GC**|`-XX:+UseConcMarkSweepGC` / `-XX:+UseG1GC`|
|**大规模内存（4GB+）**|**G1 GC**（默认）|`-XX:+UseG1GC`|
|**超大内存（100GB+）**|**ZGC / Shenandoah GC**|`-XX:+UseZGC`|

---

## **7️⃣ 总结**

|**GC 方式**|**特点**|**适用场景**|
|---|---|---|
|**Serial GC**|单线程，适合小型应用|桌面应用、单线程程序|
|**Parallel GC**|高吞吐，适合批量计算|批量任务、大数据处理|
|**CMS GC**|低延迟，适合 Web 服务器|Web 服务器、交互系统|
|**G1 GC**|适合大内存（默认）|JVM 4GB+ 大内存应用|
|**ZGC**|超低延迟（<10ms）|100GB+ 大数据应用|

# 29. G1（Garbage First）垃圾回收器的回收步骤

G1（Garbage First）是**JDK 9+ 默认 GC**，专为**大内存低延迟应用**设计，采用**区域化（Region-based）+ 并发回收**，减少**STW（Stop-the-world）时间**。

---

## **1️⃣ G1 GC 回收步骤**

G1 GC 主要分为以下 5 个阶段：

| **阶段**                          | **是否 STW** | **主要作用**                         |
| ------------------------------- | ---------- | -------------------------------- |
| **1. 年轻代回收（Young GC）**          | ✅ 是        | 回收 Eden 区，将存活对象复制到 Survivor 或老年代 |
| **2. 并发标记（Concurrent Marking）** | ❌ 否        | **标记老年代存活对象**，计算回收优先级            |
| **3. 混合回收（Mixed GC）**           | ✅ 是        | **回收年轻代 + 部分老年代**，避免 Full GC     |
| **4. 清理阶段（Cleanup）**            | ✅ 是        | **释放完全空的 Region**，优化内存           |
| **5. Full GC（全局回收）**            | ✅ 是        | **最后兜底回收，STW 时间长**               |

---

## **2️⃣ G1 GC 各阶段详细解析**

### **✅ 1. 年轻代回收（Young GC）**

**触发条件**：Eden 区满  
**作用**：

- 清理 Eden 区，将存活对象复制到 **Survivor** 或 **老年代**。
- **只回收年轻代**，**不会影响老年代**。

📌 **过程**

1. **Eden → Survivor**：存活对象移动到 Survivor（存活次数 < `MaxTenuringThreshold`）。
2. **Survivor 交换**：S0 <-> S1，部分对象晋升到老年代。
3. **Eden 清空**，等待新对象分配。

**🔹 STW 影响**：**短暂停顿**（<10ms），影响不大。

---

### **✅ 2. 并发标记（Concurrent Marking）**

**触发条件**：老年代使用率达到 `-XX:InitiatingHeapOccupancyPercent`（默认 45%）  
**作用**：

- **标记老年代的存活对象**，并计算回收价值（最垃圾的区域先回收）。
- **并发执行**（不会暂停线程）。

📌 **过程**

1. **初始标记（Initial Mark，STW）**：
    
    - **标记 GC Roots 可达对象**。
    - **与 Minor GC 结合，时间很短**。
2. **并发标记（Concurrent Marking）**：
    
    - **扫描整个堆**，跟踪对象存活情况（**线程可正常运行**）。
    - **低优先级**，后台执行，降低对应用的影响。
3. **重新标记（Remark，STW）**：
    
    - **解决并发期间的新生对象问题**（处理增量更新）。
    - **时间短，STW 影响小**。
4. **筛选阶段（Cleanup，STW）**：
    
    - 计算各个 Region 的**回收收益**，优先回收垃圾最多的区域。

**🔹 STW 影响**：

- **只有 Initial Mark 和 Remark 需要 STW**，影响较小。

---

### **✅ 3. 混合回收（Mixed GC）**

**触发条件**：并发标记完成后，根据回收优先级触发  
**作用**：

- **同时回收年轻代 + 老年代**，减少 Full GC 发生概率。
- **优先回收垃圾最多的老年代 Region**。

📌 **过程**

1. **回收 Eden + Survivor**（类似 Young GC）。
2. **部分老年代回收**（垃圾最多的 Region 先回收）。
3. **对象存活时可能晋升到老年代**。

**🔹 STW 影响**：

- **STW 时间较短**（比 Full GC 更快）。
- **回收老年代会导致部分线程暂停**，但比 CMS GC **碎片化问题更少**。

---

### **✅ 4. 清理阶段（Cleanup）**

**触发条件**：Mixed GC 结束后  
**作用**：

- **释放完全空的 Region**（无存活对象）。
- **合并碎片化的内存块**，防止 GC 退化。

📌 **过程**

1. **判断哪些 Region 没有存活对象**，直接释放。
2. **合并小的空 Region，减少内存碎片**。
3. **重新计算分配策略，优化内存布局**。

**🔹 STW 影响**：

- 仅 STW **短暂清理内存**，影响极小。

---

### **✅ 5. Full GC（全局回收）**

**触发条件**：

- **老年代满了**（Mixed GC 无法及时清理）。
- **G1 GC 运行失败**。

**作用**：

- **回收整个堆（年轻代 + 老年代）**。
- **整理所有 Region**，消除碎片化。

📌 **过程**

1. **Stop-the-world（STW）暂停所有线程**。
2. **遍历整个堆，清理所有垃圾对象**。
3. **对象整理，移动存活对象，防止碎片化**。

**🔹 STW 影响**：

- **最严重的 GC 暂停**（可能 >1s）。
- **优化方式**：
    - **调优 Mixed GC**，避免 Full GC 触发。
    - **增加 `-XX:MaxHeapSize`，提供更多堆空间**。

---

## **3️⃣ G1 GC 的优势**

|**对比项**|**G1 GC**|**CMS GC**|
|---|---|---|
|**STW 时间**|**可控（设置 `-XX:MaxGCPauseMillis`）**|偶尔长时间 STW|
|**碎片整理**|**自动整理**，无碎片问题|**容易碎片化**|
|**大堆支持**|**适用于 4GB+ 大堆**|**适用于中等大小堆**|
|**吞吐量**|**更高吞吐**|一般|

🚀 **G1 GC 适用于低延迟 + 大内存应用（Web 服务器、大数据）！**

---

## **4️⃣ G1 GC 调优**

### **✅ 基础参数**

|JVM 参数|作用|
|---|---|
|`-XX:+UseG1GC`|启用 G1 GC（JDK 9+ 默认）|
|`-XX:MaxGCPauseMillis=200`|设定**最大 GC 停顿时间（毫秒）**|
|`-XX:InitiatingHeapOccupancyPercent=45`|老年代占用多少比例触发并发标记（默认 45%）|
|`-XX:G1MixedGCCountTarget=8`|控制 Mixed GC 每次回收 Region 数量|

---

## **5️⃣ G1 GC 总结**

|**步骤**|**作用**|**STW 影响**|
|---|---|---|
|**年轻代回收（Young GC）**|Eden 区满时触发|**短暂 STW**|
|**并发标记（Concurrent Marking）**|标记老年代存活对象|**大部分无 STW**|
|**混合回收（Mixed GC）**|**年轻代 + 老年代回收**|**适中 STW**|
|**清理（Cleanup）**|释放空 Region，整理碎片|**影响小**|
|**Full GC**|兜底回收（STW 长）|**影响大，需避免**|

🚀 **G1 GC 采用分区+并发+可预测停顿，适用于大内存低延迟应用！** 💡

# 30. G1 GC特点与局限性

G1（Garbage First）GC 采用**区域化管理**内存，结合**并发标记**和**混合回收**，在**低延迟和大内存应用**中表现优秀。但它也有一些局限性。

---

## **1️⃣ G1 回收器的存储特点**

### **✅ 1.1 采用 Region（分区存储）**

- G1 **不区分固定的新生代和老年代**，而是**将堆划分成多个大小相等的 Region（区域）**。
- 每个 Region **可动态调整角色**（Eden、Survivor、Old）。
- **减少内存碎片问题**，提高 GC 效率。

- **Eden / Survivor（新生代）** → 存放**短生命周期对象**，由 Minor GC 处理。
- **Old（老年代）** → 存放**长期存活对象**，由 Mixed GC 处理。
- **Free（空闲区）** → 备用的 Region，可以随时变成其他类型。

📌 **优势**

- 避免固定比例的年轻代/老年代分配问题。
- **动态调整代际比例**，提高内存利用率。

---

### **✅ 1.2 采用增量回收**

- G1 **不会一次性回收整个堆**，而是**选择垃圾最多的 Region 进行回收**。
- **分阶段进行 GC**，降低单次 GC 停顿时间。

📌 **优势**

- **减少 STW（Stop-the-world）时间**，提高吞吐量。
- **适用于大内存应用（4GB+）**，避免一次性 Full GC 带来的长时间暂停。

---

### **✅ 1.3 自动内存整理，减少碎片**

- **传统 GC（如 CMS）会产生内存碎片**，影响大对象分配。
- **G1 自动整理 Region，移动存活对象，清理空 Region**。
- **确保堆内存连续可用，防止 OOM（Out of Memory）**。

📌 **优势**

- **适用于长期运行的应用**（如 Web 服务器、大数据处理）。
- **减少 GC 退化（不容易触发 Full GC）**。

---

### **✅ 1.4 适用于大内存（4GB+）**

- G1 **默认最小堆内存 4GB，推荐 8GB 以上**。
- G1 **支持 TB 级大内存**，ZGC 之前 G1 是唯一适用于超大堆的 GC。

📌 **适用场景**

- **Web 服务器（高吞吐，低延迟）**
- **金融交易系统（大内存，长时间运行）**
- **大数据处理（Hadoop、Spark）**

---

## **2️⃣ G1 回收器的不足**

### **❌ 2.1 单个 Region 不能超过 32MB**

- G1 采用**Region 分区**，每个 Region 最大 32MB。
- **如果对象过大（如 100MB+），则直接进入老年代，可能触发 Full GC**。

📌 **影响**

- **大对象（如长数组、大型缓存）会降低 G1 GC 效率**。
- **可能导致 Full GC 频率升高**。

🔹 **解决方案**

- 调整 `-XX:G1HeapRegionSize=32m`，避免过小的 Region 数量过多。
- 使用 **`-XX:+UseLargePages`** 让 JVM 支持更大页的分配。

---

### **❌ 2.2 Mixed GC 停顿时间不可控**

- G1 **优先回收年轻代**，但当老年代积累过多时，会触发**Mixed GC**（同时清理 Young + Old）。
- **如果老年代增长过快，Mixed GC 可能导致长时间 STW**。

📌 **影响**

- **长生命周期对象过多时，老年代膨胀，G1 GC 可能出现抖动**。
- **Mixed GC 无法完全回收老年代，最终触发 Full GC，影响性能**。

🔹 **解决方案**

- 设置 `-XX:InitiatingHeapOccupancyPercent=40` 降低老年代触发 GC 的阈值。
- 适当提高 `-XX:G1MixedGCCountTarget=8`，增加每次回收的老年代 Region 数量。

---

### **❌ 2.3 CPU 开销较大**

- G1 GC **在后台运行多个线程** 进行并发标记、回收，**可能占用较多 CPU 资源**。
- 对于**CPU 资源有限**的系统（如小型 Java 应用），G1 GC 可能带来性能开销。

📌 **影响**

- 适用于**多核 CPU**，但在**低 CPU 资源**情况下，可能影响主业务线程。

🔹 **解决方案**

- 调整 `-XX:ParallelGCThreads=4` 限制 GC 线程数。
- 低 CPU 服务器可考虑 **Parallel GC** 代替 G1。

---

### **❌ 2.4 触发 Full GC 时，暂停时间较长**

- G1 **尽量避免 Full GC**，但如果 Mixed GC 无法及时回收，最终会触发 Full GC。
- **Full GC 采用单线程标记 + 清除，会导致长时间 STW**（可能 1s 以上）。

📌 **影响**

- **对于低延迟系统（如实时交易系统），Full GC 可能导致短暂的请求卡顿**。

🔹 **解决方案**

- 设置 `-XX:MaxGCPauseMillis=200` 限制最大 GC 停顿时间。
- 降低 `-XX:InitiatingHeapOccupancyPercent=40`，让 G1 更早启动 Mixed GC。

---

## **3️⃣ 总结**

|**特点 / 不足**|**说明**|**影响**|
|---|---|---|
|**✅ 采用 Region 分区存储**|动态调整代际比例，减少碎片|提高大内存利用率|
|**✅ 并发标记，减少 STW**|标记过程不会暂停线程|提高吞吐量|
|**✅ 自动内存整理**|避免 CMS GC 碎片问题|大对象管理更高效|
|**✅ 适用于 4GB+ 大内存**|高吞吐，适用于服务器|JVM 默认 GC|
|**❌ 单个 Region 不能超过 32MB**|大对象可能直接进入老年代|增加 Full GC 可能性|
|**❌ Mixed GC 停顿时间不可控**|老年代过大时，Mixed GC 可能延迟|影响实时性|
|**❌ CPU 开销较高**|并发 GC 线程可能影响业务线程|低 CPU 机器性能下降|
|**❌ Full GC STW 时间长**|兜底回收效率低|可能影响高并发应用|

🚀 **最佳应用场景**

1. **大内存（4GB+）+ 高吞吐（Web 服务器）**
2. **长时间运行的 Java 服务（如金融、在线游戏、搜索引擎）**
3. **需要减少 Full GC 发生的应用（如大数据处理）**

🚀 **避免 G1 GC 的场景**

1. **低 CPU 服务器（G1 线程开销较大）**
2. **大量大对象应用（避免 Region 过小）**
3. **超低延迟应用（如实时交易系统，可能触发长时间 Full GC）**

💡 **G1 GC 通过区域化 + 并发回收提升了吞吐量，但仍需调优 Mixed GC，防止 Full GC 影响性能！** 🔥

# 31. volatile关键字底层原理

### **`volatile` 关键字的底层原理**

`volatile` 是 Java **并发编程**中的关键字，主要用于**保证变量的可见性**，避免**指令重排序**，但**不保证原子性**。

---

## **1️⃣ `volatile` 的作用**

✅ **保证可见性**：**修改 `volatile` 变量后，所有线程立即可见**。  
✅ **禁止指令重排序**：**防止 CPU 乱序执行，保证代码顺序**。  
❌ **不保证原子性**：`volatile` 变量的**复合操作（如 `i++`）仍然可能发生竞态条件**。

---

## **2️⃣ `volatile` 底层原理**

### **✅ 2.1 可见性原理（内存屏障 + 缓存一致性协议）**

**问题**：普通变量在**多线程环境下可能不可见**，因为 CPU **缓存机制**：

- **每个线程可能在 CPU 缓存中读取变量值**，不会立即从**主内存**获取最新值。
- **线程修改变量后，其他线程可能看不到更新**，仍然使用旧值。

**`volatile` 如何保证可见性？**

- **底层使用 `lock` 指令或 `memory barrier（内存屏障）`，保证修改对所有线程可见**。
- **触发 CPU 缓存一致性协议（MESI）**：
    - 线程修改 `volatile` 变量时，会**强制刷新到主内存**。
    - **其他 CPU 核心的缓存行失效**，重新从主内存读取最新值。

- **线程 A 修改 `flag=false`**，会**立即刷新到主内存**。
- **线程 B 读取 `flag` 时，必须重新从主内存获取**，不会读取旧值。

---

### **✅ 2.2 禁止指令重排序**

**问题**：JVM 和 CPU 可能会**优化代码执行顺序（指令重排序）**，导致程序逻辑异常。

**`volatile` 如何防止指令重排序？**

- `volatile` **底层使用 `StoreLoad` 内存屏障**，保证写入 `volatile` 变量的操作**不会被重排序**。
- **防止编译器 & CPU 优化时调整代码执行顺序**。

---

## **3️⃣ `volatile` 在 JVM 底层的实现**

**JVM 通过 `volatile` 关键字，在 `class` 字节码中添加 `ACC_VOLATILE` 修饰符**。

📌 **字节码层面**

- **JVM 确保 `volatile` 变量的读取和写入**，都**不会被 CPU 缓存优化**。
- **防止指令重排序，保证可见性**。

📌 **底层汇编**

- `lock` 指令：**保证 CPU 缓存一致性**，让 `volatile` 变量的修改对所有线程可见。

---

## **4️⃣ `volatile` vs `synchronized`**

|**对比项**|**`volatile`**|**`synchronized`**|
|---|---|---|
|**作用**|**保证可见性** & **防止重排序**|**保证可见性 + 原子性 + 互斥**|
|**是否阻塞**|**非阻塞**|**阻塞（获取锁）**|
|**性能**|**高（轻量级）**|**较低（线程竞争）**|
|**适用场景**|**简单状态变量（如 `flag`）**|**复合操作（如 `i++`、`List.add()`）**|

---

## **5️⃣ 适用场景**

🚀 **推荐使用 `volatile` 的场景**

- **状态标志位（如 `boolean flag`）**。
- **单例模式的 `DCL（双重检查锁）`**。
- **轻量级的变量同步，不涉及复合操作**。

🚫 **不能使用 `volatile` 的场景**

- **i++、对象属性更新等非原子操作**（需使用 `synchronized` 或 `Atomic` 类）。
- **需要保证线程安全的复杂逻辑**（`volatile` 只能保证变量本身的可见性）。

---

## **6️⃣ 总结**

✅ **`volatile` 通过** **内存屏障 + CPU 缓存一致性协议** **保证可见性**。  
✅ **`volatile` 禁止指令重排序，避免乱序执行问题**。  
❌ **`volatile` 不保证原子性，不能替代 `synchronized`**。  
🚀 **适用于状态标志、DCL 单例，但不适用于 `i++` 等复合操作**！

# 32. JIT（Just-In-Time，即时编译器）

JIT（即时编译器）是 **JVM（Java 虚拟机）中的核心组件**，用于**动态将字节码编译为本地机器码，提高 Java 程序执行效率**。

---

## **1️⃣ JIT（即时编译）与解释执行**

Java 代码通常**不会直接被 CPU 执行**，而是：

1. **编译阶段**：Java 源代码（`.java`）**被编译成字节码（`.class`）**，由 JVM 执行。
2. **执行阶段**：
    - **解释执行（Interpreter）**：逐条翻译字节码，执行速度较慢。
    - **JIT 编译（即时编译）**：热点代码会被**JIT 编译成本地机器码**，加速执行。

📌 **JIT 的作用**：

- **提高执行速度**（字节码 → 直接变成本地机器码）。
- **减少重复解释开销**（常用代码缓存为机器码）。
- **动态优化代码**（如**方法内联、循环展开**）。

---

## **2️⃣ JIT 编译器的工作流程**


📌 **JIT 编译流程**

1. **JVM 先解释执行代码**（启动时 JIT 还不会生效）。
2. **发现热点代码（多次执行的方法 / 循环）**，触发 JIT 编译。
3. **JIT 编译器将热点代码翻译成本地机器码**，提高执行效率。
4. **优化已编译代码**，如方法内联、循环展开、去除无用代码等。

---

## **3️⃣ JIT 主要优化策略**

JIT 采用多种优化策略，以提高 Java 代码执行效率：

|**优化策略**|**作用**|
|---|---|
|**方法内联（Method Inlining）**|**减少方法调用开销**（小方法直接展开到调用处）。|
|**循环展开（Loop Unrolling）**|**减少循环次数，提高效率**。|
|**常量传播（Constant Propagation）**|**消除不必要的变量赋值**，提高执行速度。|
|**冗余代码消除（Dead Code Elimination）**|**去除永远不会执行的代码**。|
|**逃逸分析（Escape Analysis）**|**对象优化：栈上分配、消除同步锁**，减少 GC 负担。|

---

## **4️⃣ JIT 编译器的类型**

JVM **默认提供 2 种 JIT 编译器**：

|**JIT 编译器**|**特点**|**适用场景**|
|---|---|---|
|**C1 编译器（Client Compiler）**|**启动快，优化少**|适用于 **桌面应用、低延迟场景**|
|**C2 编译器（Server Compiler）**|**启动慢，但优化强大**|适用于 **高性能服务器应用**|

📌 **如何选择 JIT 模式？**

- **`-XX:+TieredCompilation`（默认）**：先用 C1，再用 C2（平衡启动速度和性能）。
- **`-XX:+UseC2`**：强制使用 C2，适合**长时间运行的高性能应用**。
- **`-XX:+UseC1`**：适用于**低延迟应用，减少 JIT 影响**。

---

## **5️⃣ 逃逸分析（JIT 关键优化）**

JIT **通过逃逸分析优化对象分配，减少 GC 压力**。

✅ **三种优化方式**：

|**优化策略**|**作用**|
|---|---|
|**栈上分配（Stack Allocation）**|局部对象**直接分配在栈**上，方法执行完即销毁，避免 GC|
|**同步消除（Lock Elimination）**|如果对象不会逃逸到多线程，则**去掉 `synchronized`**|
|**标量替换（Scalar Replacement）**|拆分对象，使其部分变量直接存入 CPU 寄存器|

---

## **6️⃣ JIT 监控与优化**

✅ **JIT 监控命令**

|**命令**|**作用**|
|---|---|
|`-XX:+PrintCompilation`|查看 JIT 编译的热点方法|
|`-XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation`|详细记录 JIT 编译日志|
|`-XX:+TieredCompilation`|开启分层编译（C1 + C2）|

✅ **优化方式**

- **减少短时间运行的代码 JIT 编译**（`-XX:+TieredCompilation`）。
- **使用逃逸分析减少对象分配**（`-XX:+DoEscapeAnalysis`）。
- **手动调整 JIT 触发条件**（`-XX:CompileThreshold=10000`）。

---

## **7️⃣ 总结**

✅ **JIT 通过即时编译提升 Java 性能**，将**热点代码转为机器码**。  
✅ **两种 JIT 编译器：C1（快速启动） & C2（高性能）**。  
✅ **优化策略包括方法内联、循环展开、逃逸分析等**，减少 GC 负担。

# 33. 反射及其原理

## **1️⃣ 什么是反射（Reflection）？**

**反射（Reflection）** 是 Java 提供的一种**动态操作机制**，允许程序在运行时**动态地获取类的信息（类名、字段、方法、构造器）并进行操作**，即使在编译时这些信息是未知的。

### **📌 反射的核心功能**

- **获取类的信息**（Class 对象）
- **获取和修改字段（属性）**
- **调用方法**
- **创建对象（实例化）**
- **获取类的构造方法**
- **获取类的注解**

---

## **2️⃣ 反射的工作原理**

### **📌 反射的核心组件**

Java 反射机制的核心在于 **`java.lang.Class`、`java.lang.reflect.Method`、`java.lang.reflect.Field`、`java.lang.reflect.Constructor`**。

### **📌 反射的执行流程**

1. **获取类的 Class 对象**
    
    - `Class.forName("类名")`
    - `类名.class`
    - `对象.getClass()`
2. **获取类的字段、方法、构造器**
    
    - `getDeclaredFields()` 获取所有属性
    - `getDeclaredMethods()` 获取所有方法
    - `getDeclaredConstructors()` 获取所有构造方法
3. **操作字段、方法**
    
    - `field.set(obj, value)` 修改字段值
    - `method.invoke(obj, args...)` 调用方法
    - `constructor.newInstance(args...)` 通过构造器实例化对象
4. **访问私有字段或方法**
    
    - `setAccessible(true)`

---

## **3️⃣ 反射的底层原理**

### **📌 Class 对象的作用**

在 Java 中，每个类在加载时，都会由 JVM 创建一个 `Class` 对象，这个对象用于存储**类的元数据**（方法、字段、构造器等）。Java 反射就是通过 **操作 `Class` 对象** 来动态调用类的属性和方法。

### **📌 反射的执行流程**

1. **类加载（ClassLoader）**
    
    - 反射需要 **JVM 先加载 Class 文件**，并在方法区存储类的元信息（类名、字段、方法等）。
2. **Class 对象在方法区存储**
    
    - JVM 在方法区（Metaspace）存储类的元数据，每个加载的类都有唯一的 `Class` 对象。
3. **通过 `Class` 获取信息**
    
    - 反射 API 通过 `Class` 对象，查询字段、方法等。
4. **调用字段和方法**
    
    - 通过 `Field.set()` 修改属性
    - 通过 `Method.invoke()` 调用方法

---

## **4️⃣ 反射的优缺点**

### **✅ 优点**

1. **动态性强**：可以在运行时动态调用类和方法，适用于框架开发（如 Spring、Hibernate）。
2. **解耦代码**：可以在不知道类的情况下调用它的方法，如 **插件机制、序列化框架**。
3. **支持泛型和注解**：反射可以解析注解，适用于 **AOP、依赖注入**。

### **❌ 缺点**

1. **性能开销大**
    
    - 反射比普通方法调用 **慢 10~20 倍**（涉及方法查找、权限检查）。
    - **避免高频调用**，如在循环中使用 `Method.invoke()`。
2. **代码复杂，难以维护**
    
    - 反射代码通常比普通代码难理解，容易出现异常。
3. **安全问题**
    
    - 反射可以访问私有字段和方法，可能被**恶意篡改**，存在安全隐患。

---

## **5️⃣ 反射的优化**

### **📌 1. 尽量避免高频使用**

- **缓存 Method / Field**
- **尽量使用普通调用**

### **📌 2. 使用 JDK `MethodHandle`（比反射快 3~4 倍）**

Java 7 引入 `MethodHandle`，直接调用方法，绕过反射机制。

### **📌 3. 使用 CGLIB 代理**

CGLIB 通过**字节码增强**技术（ASM），比反射快 **5~10 倍**。

---

## **6️⃣ 反射的应用场景**

### **📌 1. Java 框架（Spring、MyBatis）**

- **Spring 依赖注入（DI）**：使用反射为 `@Autowired` 注入 Bean。
- **Spring AOP（面向切面编程）**：动态代理拦截方法调用。

### **📌 2. 动态加载类（Class.forName()）**

- **插件机制**：可以在运行时加载不同的插件类（如 JDBC Driver）。
- **序列化与反序列化**：如 Gson、Jackson 解析 JSON。

### **📌 3. 注解处理**

- Java 反射可以解析注解，例如 `@Autowired`、`@Transactional`。

---

## **7️⃣ 结论**

- **反射 = 运行时操作类的属性、方法、构造器**
- **优点**：动态性强、解耦、适用于框架开发
- **缺点**：性能损耗大、安全性低
- **优化**：
    - **缓存 Method/Field**
    - **使用 MethodHandle**
    - **使用 CGLIB 代理**
- **应用场景**：
    - **Spring 框架（DI、AOP）**
    - **序列化/反序列化**
    - **插件机制**

🚀 **合理使用反射，避免性能损耗，提升 Java 应用的灵活性！**

# 34. synchronized底层实现

在 Java 并发编程中，`synchronized` 关键字用于**保证多线程访问共享资源时的互斥性**，即同一时刻最多只有一个线程可以执行 `synchronized` 代码块。它是 **Java 提供的内置锁（Intrinsic Lock 或 Monitor Lock）**，由 JVM 实现。

---

## **1️⃣ `synchronized` 的基本用法**

### **📌 `synchronized` 作用范围**

`Synchronized` 可以修饰以下三种结构：

1. **修饰实例方法**（锁住当前对象）
2. **修饰静态方法**（锁住类对象 `Class`）
3. **修饰代码块**（锁住指定对象）

---

## **2️⃣ `synchronized` 的底层原理**

`synchronized` **底层依赖 JVM 实现**，核心机制包括：

1. **对象头（Mark Word）存储锁信息**
2. **Monitor 监视器锁（Monitor Enter / Exit）**
3. **基于 CAS + 自旋锁优化**

---

## **3️⃣ `synchronized` 在 JVM 内部的执行**

### **📌 3.1 `synchronized` 依赖对象头**

Java 中的每个对象在 JVM 内存中都有一个 **对象头（Object Header）**，`synchronized` 主要依赖 **对象头的 `Mark Word` 记录锁状态**。

|**Mark Word（对象头）信息**|**状态**|
|---|---|
|无锁（Normal）|线程 ID 为空|
|偏向锁（Biased）|记录**线程 ID**，同一线程可重复进入|
|轻量级锁（Lightweight）|通过 CAS 机制竞争锁|
|重量级锁（Heavyweight）|线程阻塞，进入 **Monitor**|

---

### **📌 3.2 `synchronized` 依赖 `Monitor`**

在 Java 字节码层面，`synchronized` 代码块会被编译成：

- `monitorenter`（获取锁）
- `monitorexit`（释放锁）

📌 **Monitor 机制**

- **底层依赖 `ObjectMonitor`**
- `Monitor` 采用 **互斥机制**，同一时刻只能有一个线程进入
- `Monitor` 依赖 **`wait()`、`notify()`** 进行线程协调

✅ **Monitor 内部结构**

cpp

复制编辑

`ObjectMonitor {     int _owner;      // 持有锁的线程 ID     int _count;      // 重入次数     List _waitSet;   // 等待队列     List _entryList; // 竞争锁的线程队列 }`

- `_owner`：记录当前持有锁的线程 ID
- `_count`：记录**锁的重入次数**
- `_entryList`：竞争 `synchronized` 代码块的线程队列
- `_waitSet`：被 `wait()` 暂停的线程队列

---

## **4️⃣ `synchronized` 的优化（锁升级过程）**

### **📌 4.1 锁的四种状态**

为了提高性能，JVM **针对 `synchronized` 实现了锁优化**，锁可以从 **偏向锁 → 轻量级锁 → 重量级锁** 逐步升级。

|**锁类型**|**特点**|**适用场景**|
|---|---|---|
|**无锁**（Normal）|没有竞争，无需加锁|线程安全的方法|
|**偏向锁**（Biased）|**同一线程反复进入**，减少 CAS 竞争|**单线程执行**|
|**轻量级锁**（Lightweight）|竞争时，**CAS + 自旋** 替代阻塞|低竞争，短时间锁持有|
|**重量级锁**（Heavyweight）|线程阻塞，**进入 `Monitor`**|**高竞争场景**|

---

### **📌 4.2 偏向锁（Biased Locking）**

**适用场景**：

- 适用于 **单线程反复进入同步块**
- **无竞争时避免 CAS 操作**

**工作方式**：

- 线程获取锁时，在对象头的 `Mark Word` **记录线程 ID**
- **如果同一线程再次进入**，**无需重新加锁**

📌 **偏向锁的撤销**

- 当另一个线程访问锁对象时，偏向锁会**撤销并升级**到轻量级锁

---

### **📌 4.3 轻量级锁（Lightweight Locking）**

**适用场景**：

- 适用于**多个线程竞争但未发生阻塞**
- 采用 **CAS + 自旋锁**，避免线程阻塞

**工作方式**：

- 线程获取锁时，会**创建 Lock Record 记录**，使用 **CAS（Compare-And-Swap）** 尝试获取锁
- 如果 CAS 失败，线程 **进入自旋**，不会立即阻塞
- 如果**竞争激烈**，锁升级为**重量级锁**

📌 **轻量级锁的失败**

- 当 **多个线程同时竞争锁** 且 CAS 失败次数过多时，升级为**重量级锁**

---

### **📌 4.4 重量级锁（Heavyweight Locking）**

**适用场景**：

- **线程竞争激烈时**
- `CAS + 自旋锁` 失效，线程进入**阻塞队列**

**工作方式**：

- 线程竞争锁失败后，会**被操作系统挂起**，降低 CPU 资源消耗
- 依赖 **Monitor + `wait()` + `notify()`**

📌 **性能问题**

- 线程切换成本高
- 适用于**高竞争同步场景**

---

## **5️⃣ `synchronized` vs `Lock`**

|**对比项**|**synchronized**|**Lock（ReentrantLock）**|
|---|---|---|
|**锁类型**|JVM 内置锁|显式锁|
|**公平性**|非公平|可选择公平/非公平|
|**可重入性**|✅ 可重入|✅ 可重入|
|**锁升级**|偏向锁 → 轻量级锁 → 重量级锁|无锁升级机制|
|**性能**|**较低（线程阻塞）**|**较高（避免阻塞）**|
|**是否可中断**|❌ 不可中断|✅ `lockInterruptibly()`|

🚀 **优化建议**

- **低竞争**：`synchronized` 更简单，JVM 优化后性能接近 `Lock`
- **高并发**：`ReentrantLock` 提供更精细的控制，支持 **超时、中断、公平锁**

---

## **6️⃣ 结论**

- **`synchronized` 依赖 `Monitor`，通过对象头存储锁信息**
- **锁优化（偏向锁 → 轻量级锁 → 重量级锁）提高性能**
- **适用于低竞争场景，JVM 已优化**
- **高并发环境下，`Lock` 更灵活，可替代 `synchronized`**

💡 **合理选择 `synchronized` 和 `Lock`，提高并发性能！🚀**

# 35. 死锁产生的原因及解决方案

## **1️⃣ 什么是死锁？**

**死锁（Deadlock）** 指的是多个线程或进程在执行过程中，**因为竞争资源而相互等待，导致程序无法继续执行**。当每个线程都持有某些资源，并等待其他线程释放资源时，就可能形成**死锁**。

---

## **2️⃣ 死锁的四个必要条件（"柯林斯四条件"）**

死锁的发生必须同时满足以下 **4 个条件**，只要破坏其中任何一个条件，就可以**避免死锁**。

|**条件**|**含义**|**示例**|
|---|---|---|
|**互斥（Mutual Exclusion）**|资源一次只能被**一个线程**占用|**打印机只能被一个任务使用**，其他任务必须等待|
|**持有并等待（Hold and Wait）**|线程**已持有一个资源**，同时**等待另一个资源**|**线程 A 持有资源 1，等待资源 2**，但资源 2 被线程 B 持有|
|**不可剥夺（No Preemption）**|线程无法强制释放资源，**只能主动释放**|**任务执行未完成，不能强行终止占用的资源**|
|**循环等待（Circular Wait）**|线程形成**资源环路依赖**，导致死锁|**A → B → C → A，循环等待资源释放**|

📌 **只有同时满足以上四个条件，才会发生死锁**，破坏任何一个条件即可避免死锁。

---

## **3️⃣ 死锁的常见产生原因**

### **📌 1. 多线程资源竞争**

🔹 **问题**：

- 线程 A 持有 **资源 1**，等待 **资源 2**。
- 线程 B 持有 **资源 2**，等待 **资源 1**。
- **相互等待对方释放资源，形成死锁**。

🔹 **示例**

|**线程 A**|**线程 B**|
|---|---|
|`lock(资源 1)`|`lock(资源 2)`|
|`等待 资源 2`|`等待 资源 1`|
|**死锁发生**|**死锁发生**|

🔹 **解决方案** ✅ **所有线程获取资源的顺序必须相同**，避免交叉等待。

---

### **📌 2. 嵌套锁（Nested Locking）**

🔹 **问题**：

- 线程 A 持有 **锁 X**，等待 **锁 Y**，而线程 B 先持有 **锁 Y**，等待 **锁 X**，形成死锁。

🔹 **示例**

|**线程 A**|**线程 B**|
|---|---|
|`synchronized(锁 X)`|`synchronized(锁 Y)`|
|`synchronized(锁 Y)`（等待）|`synchronized(锁 X)`（等待）|
|**死锁发生**|**死锁发生**|

🔹 **解决方案** ✅ **使用 `tryLock()`（非阻塞锁）**，如果无法获取锁，则主动释放已有锁，避免死锁。

---

### **📌 3. 线程池死锁**

🔹 **问题**：

- 线程池大小不足，导致**任务相互等待线程资源**，最终所有任务都无法执行。

🔹 **示例**

- **任务 A 依赖 任务 B**，但任务 B **等待线程池调度**，导致死锁。

🔹 **解决方案** ✅ **合理设置线程池大小，避免任务嵌套提交**。

---

### **📌 4. 事务锁等待**

🔹 **问题**：

- 事务 A 修改 **表 A**，事务 B 修改 **表 B**，然后事务 A 需要访问 **表 B**，事务 B 需要访问 **表 A**，导致**相互锁定，发生死锁**。

🔹 **示例**

|**事务 A**|**事务 B**|
|---|---|
|`UPDATE 表 A`|`UPDATE 表 B`|
|`等待 表 B`（锁定）|`等待 表 A`（锁定）|
|**死锁发生**|**死锁发生**|

🔹 **解决方案** ✅ **确保事务访问表的顺序一致**，避免交叉锁定不同资源。

---

### **📌 5. 数据库并发控制（锁超时）**

🔹 **问题**：

- **数据库锁（如 MySQL 行锁）** 可能导致事务之间**相互等待资源释放**，形成死锁。

🔹 **示例**

|**事务 A**|**事务 B**|
|---|---|
|`SELECT ... FOR UPDATE`|`SELECT ... FOR UPDATE`|
|`等待另一个事务提交`|`等待另一个事务提交`|
|**死锁发生**|**死锁发生**|

🔹 **解决方案** ✅ **设置事务超时时间**，如果事务执行过长，则主动回滚，释放锁资源。

---

## **4️⃣ 解决死锁的常见方法**

|**解决方案**|**方式**|**破坏的死锁条件**|
|---|---|---|
|**资源顺序一致**|所有线程按照**相同顺序**获取资源|**破坏循环等待**|
|**使用 `tryLock()`**|**尝试加锁**，如果失败则释放已持有的锁|**破坏不可剥夺**|
|**设置超时机制**|设置**事务、锁等待超时**，避免长时间等待|**破坏不可剥夺**|
|**避免嵌套锁**|避免多个锁相互依赖|**破坏持有并等待**|
|**使用事务回滚**|在超时情况下**主动回滚事务**|**破坏不可剥夺**|

---

## **5️⃣ 结论**

- **死锁的发生必须满足四个必要条件**（互斥、持有并等待、不可剥夺、循环等待）。
- **死锁的常见原因**：
    - **资源竞争**（两个线程等待对方释放资源）
    - **嵌套锁**（多个锁相互等待）
    - **线程池死锁**（任务相互依赖，但线程池已满）
    - **事务死锁**（数据库事务锁互相等待）
- **解决方案**：
    - **资源顺序固定**，避免交叉等待
    - **使用 `tryLock()` 失败时主动释放已有锁**
    - **设置超时时间，避免长期锁定**
    - **避免事务长时间占用资源**

🚀 **合理设计线程同步和数据库事务管理，防止死锁，提高系统稳定性！🔥**

# 36. 线程池死锁的原因及解决方案

在 Java 线程池（`ThreadPoolExecutor`）中，**死锁（Deadlock）** 可能会导致所有线程无法继续执行，最终应用卡死或性能下降。死锁通常发生在**任务之间存在循环依赖** 或 **线程资源不足** 的情况下。

---

## **1️⃣ Java 线程池死锁的常见原因**

### **📌 1. 线程池大小过小，任务相互依赖**

🔹 **问题描述**

- 当一个任务**依赖另一个任务的结果**，但另一个任务**还未被线程池执行**，会导致线程池阻塞。
- **线程池核心线程数过小**，导致任务始终无法执行，最终形成**死锁**。

🔹 **示例**

- **任务 A 依赖 任务 B**，但任务 B **需要线程执行**，而线程池已满，导致任务 B **无法被调度**，任务 A 也无法继续执行。

🔹 **解决方案** ✅ **合理设置线程池大小**

- 线程池核心线程数应 **≥ 任务最大嵌套深度**，防止任务因等待子任务而死锁。
- **使用 `newCachedThreadPool()`**（动态扩展线程池大小），让线程池能够处理更多任务。

---

### **📌 2. 使用 `FixedThreadPool` 执行同步任务**

🔹 **问题描述**

- **`FixedThreadPool(n)` 线程池**，如果某个任务**提交了额外的子任务**，而线程池中的线程已经被占满，子任务无法获得可用线程，导致死锁。

🔹 **示例**

- 线程池 `FixedThreadPool(2)`，任务 A 和任务 B 占用了两个线程。
- 任务 A **在执行过程中提交了任务 C**，但 C **无法被执行**（线程已占满）。
- **任务 A 需要等待任务 C 的执行结果**，导致线程池死锁。

🔹 **解决方案** ✅ **使用 `CallerRunsPolicy` 让主线程执行任务**

- `ThreadPoolExecutor` 提供 `CallerRunsPolicy`，当线程池满时，任务将在**提交任务的线程中运行**，避免完全阻塞。

✅ **改用 `newCachedThreadPool()` 或 `ForkJoinPool`**

- `newCachedThreadPool()` 线程池**会动态扩展线程数量**，不会受限于固定线程数导致死锁。
- `ForkJoinPool` 适用于**任务拆分**的情况，支持**任务窃取**，防止任务因等待子任务执行而死锁。

---

### **📌 3. 线程池任务持有锁，导致互相等待**

🔹 **问题描述**

- 如果多个线程池任务**持有锁**，并且相互等待对方释放锁，会导致**线程池中的线程陷入死锁**。

🔹 **示例**

- 线程 A 锁住资源 1，等待资源 2。
- 线程 B 锁住资源 2，等待资源 1。
- **A 和 B 互相等待对方释放锁，导致线程池死锁。**

🔹 **解决方案** ✅ **避免嵌套锁**

- **确保获取锁的顺序一致**，避免交叉锁定不同资源。

✅ **使用 `tryLock()`**

- `ReentrantLock` 提供 `tryLock()`，如果无法立即获取锁，可以**避免线程一直阻塞**。

✅ **使用 `ReadWriteLock`**

- **如果任务只需要读取数据，可以使用 `ReadLock`**，允许多个线程并发读取，减少死锁风险。

---

### **📌 4. 队列满导致主线程阻塞**

🔹 **问题描述**

- 线程池**任务队列已满**，但线程池**不会扩容**，导致提交新任务的线程**一直阻塞**，最终形成死锁。

🔹 **示例**

- 使用 `newFixedThreadPool(2)`，并设置 `LinkedBlockingQueue(2)`（队列最大长度 2）。
- 如果主线程提交了**超过 4 个任务**（2 个线程执行任务 + 2 个队列等待任务），新任务会被**阻塞提交**。
- **如果主线程在等待任务执行完成，而新任务不能进入线程池，死锁发生。**

🔹 **解决方案** ✅ **使用 `SynchronousQueue` 或 `CallerRunsPolicy`**

- `SynchronousQueue` 不会存储任务，如果线程池满了，**任务会直接交给主线程执行**，避免任务长时间等待。
- `CallerRunsPolicy` 让提交任务的线程**直接执行任务**，避免死锁。

✅ **增加 `maximumPoolSize`**

- 适当增加 `maximumPoolSize`，让线程池有足够的线程执行任务，避免任务排队等待。

---

## **2️⃣ 线程池死锁的解决方案总结**

| **死锁原因**                     | **解决方案**                                     |
| ---------------------------- | -------------------------------------------- |
| 任务相互依赖，但线程池已满                | ✅ 适当增大 `corePoolSize`，使用 `CachedThreadPool`  |
| `FixedThreadPool` 提交子任务，线程池满 | ✅ 采用 `CallerRunsPolicy` 或 `ForkJoinPool`     |
| 任务持有锁，互相等待                   | ✅ 采用 `tryLock()`，避免嵌套锁                       |
| 线程池队列满，导致提交线程阻塞              | ✅ 采用 `SynchronousQueue`，调整 `maximumPoolSize` |

---

## **3️⃣ 结论**

- **线程池死锁通常发生在任务相互依赖、锁等待、队列阻塞等情况下**。
- **避免固定线程数的 `FixedThreadPool` 造成的死锁，必要时使用 `CachedThreadPool` 或 `ForkJoinPool`**。
- **合理设置 `CallerRunsPolicy`，使用 `tryLock()` 处理锁等待问题**。
- **监控线程池状态，防止任务长时间阻塞，影响系统稳定性**。

🚀 **合理配置 Java 线程池，避免死锁，提高并发处理能力！🔥**

# 37. 线上线程池死锁的监控、排查与解决方案

## **1️⃣ 如何监控线上线程池死锁？**

线上环境死锁难以复现，因此需要**实时监控线程池状态**，确保第一时间发现问题。

### **📌 1. 监控线程状态**

#### **✅ `jstack`（线程堆栈分析）**

- **定期执行 `jstack` 命令**，查看是否有大量线程处于 `BLOCKED` 状态。
- **如果线程池任务卡死**，可能是**锁争用** 或 **线程池死锁**。

#### **✅ `jcmd`（JVM 线程监控）**

- 通过 `Thread.print` 监控线程池中的**活动线程数、等待线程、锁状态**。

#### **✅ `jvisualvm`（JVM 可视化监控）**

- 远程连接线上 JVM，查看**线程是否出现大量 `BLOCKED` 状态**。

---

### **📌 2. 监控线程池指标**

#### **✅ 关键监控项**

|**指标**|**可能问题**|
|---|---|
|`ActiveCount`|线程池中的活动线程数是否等于 `corePoolSize`（可能线程卡死）|
|`QueueSize`|任务队列是否满了，导致任务无法被执行|
|`CompletedTaskCount`|任务完成数量是否长时间不变（可能是死锁）|

#### **✅ 监控工具**

- **Prometheus + Grafana**：收集 `ThreadPoolExecutor` 指标，监控 `ActiveCount` 和 `QueueSize`。
- **SkyWalking / Zipkin**：跟踪任务执行时间，发现超时任务。
- **阿里 `Arthas`**：实时查看 JVM 线程状态，排查死锁。

---

## **2️⃣ 如何排查线上线程池死锁？**

### **📌 1. 分析 `jstack` 线程状态**

- 查找**是否有多个线程处于 `BLOCKED` 状态**，且**持有不同锁的线程互相等待**。
- 如果 `jstack` 输出 `Found one Java-level deadlock`，说明已确认死锁。

### **📌 2. 检查任务依赖关系**

- 如果线程池任务**在执行过程中提交了子任务**，但线程池已经满了，导致子任务无法被执行，可能是**死锁**。
- **日志分析**：检查任务执行顺序，是否存在**任务 A 依赖 任务 B，而任务 B 等待 任务 A**。

### **📌 3. 检查锁竞争**

- 线程池任务**是否使用了 `synchronized` 或 `ReentrantLock`**，并且不同任务互相等待。
- **监控数据库锁**（如 `SELECT ... FOR UPDATE` 是否长时间等待）。

---

## **3️⃣ 如何解决线上线程池死锁？**

### **📌 1. 立即缓解措施**

#### **✅ 临时扩容线程池**

- 如果线程池满了，导致任务无法执行，可以**动态增加 `maximumPoolSize`** 以解锁任务。
- 适用于**短期救急，但不能作为长期解决方案**。

#### **✅ 终止任务**

- **使用 `kill -3 <pid>` 生成线程堆栈**，分析哪个任务卡住。
- **手动取消长时间等待的任务**，避免阻塞其他任务。

#### **✅ 重新启动服务**

- 如果死锁无法快速解决，可以**重启服务**，让线程池恢复正常状态。

---

### **📌 2. 长期优化方案**

#### **✅ 线程池优化**

- **适当增加 `corePoolSize`，减少任务等待时间**。
- **使用 `CallerRunsPolicy` 让主线程执行任务，避免任务堆积**。
- **避免 `FixedThreadPool` 提交子任务，改用 `CachedThreadPool` 或 `ForkJoinPool`**。

#### **✅ 任务拆分**

- **避免任务相互依赖**，改为**独立线程池**执行子任务。
- **长任务拆分为多个小任务**，减少单个任务执行时间，降低死锁概率。

#### **✅ 避免锁竞争**

- **使用 `tryLock()`**，如果锁无法获取，则放弃任务，避免死锁。
- **确保获取锁的顺序一致**，避免多个任务交叉等待不同的锁。

#### **✅ 设置任务超时**

- **设定合理的任务超时时间**，如果任务超时，则强制取消执行，避免任务无限等待。

---

## **4️⃣ 结论**

### **🛠 如何监控线程池死锁？**

|**方法**|**工具**|**作用**|
|---|---|---|
|**监控线程状态**|`jstack` / `jcmd`|检查 `BLOCKED` 线程|
|**可视化监控**|`jvisualvm` / `Arthas`|实时分析线程状态|
|**监控线程池指标**|Prometheus + Grafana|监控 `ActiveCount` 和 `QueueSize`|

---

### **🛠 如何排查线程池死锁？**

|**方法**|**重点检查项**|
|---|---|
|**分析 `jstack`**|`BLOCKED` 线程，是否有锁等待|
|**检查任务依赖**|是否有任务等待其他任务执行|
|**检查锁竞争**|任务是否使用 `synchronized` 或 `ReentrantLock`|

---

### **🛠 如何解决线程池死锁？**

|**问题**|**解决方案**|
|---|---|
|**线程池任务阻塞**|适当增加 `maximumPoolSize`，避免 `FixedThreadPool` 死锁|
|**任务相互依赖**|拆分任务，使用 `ForkJoinPool`|
|**锁竞争**|改用 `tryLock()`，避免死锁|
|**任务超时**|设定任务超时机制，避免长时间等待|

🚀 **线上线程池死锁的监控、排查、优化是保障系统稳定性的重要手段，合理设计线程池，避免死锁，提高系统可靠性！🔥**

# 38. 线上流量激增导致线程池被打垮的处理方案

当线上系统遇到**流量激增**，导致**线程池被打满**，可能会出现以下问题：

- **任务大量排队**，请求响应变慢甚至超时。
- **线程池饱和**，新任务无法执行，触发**拒绝策略**。
- **CPU 负载过高**，服务器响应变慢，甚至崩溃。

为了解决这些问题，需要**快速应对**流量高峰，并采取**长期优化方案**。

---

## **1️⃣ 立即缓解方案（应急处理）**

### **📌 1. 立即扩容线程池**

- **增加 `maximumPoolSize`**，让线程池**可以接受更多请求**，减少任务排队。
- **适用于短期救急**，但不能无限扩容，避免 CPU 过载。

### **📌 2. 开启降级策略**

- **非核心业务降级**：
    - 低优先级任务直接**丢弃或返回默认值**（如推荐系统、日志存储）。
- **缓存快速返回**：
    - 使用 Redis **缓存热点数据**，减少线程池执行任务的压力。

### **📌 3. 启用限流**

- **限制高并发请求数量**：
    - **令牌桶限流（Guava RateLimiter）**：控制 QPS，防止线程池被打爆。
    - **漏桶算法**：限制请求处理速率，避免瞬间流量冲击线程池。
- **针对不同业务分开限流**：
    - **核心业务（如下单、支付）** 优先处理，**非核心业务限流**。

---

## **2️⃣ 线程池优化方案**

### **📌 1. 选择合适的任务队列**

- **使用 `SynchronousQueue`（无队列）**：
    - 适用于**请求不能排队，必须立即执行**的场景（如 API 请求）。
- **使用 `LinkedBlockingQueue`（有界队列）**：
    - 适用于**允许一定排队的情况**，避免线程数无限增长。

### **📌 2. 使用 `CallerRunsPolicy` 处理任务**

- 当线程池满时，让**提交任务的主线程执行任务**，降低线程池负载。

### **📌 3. 拆分线程池**

- **不同业务使用独立的线程池**，避免关键业务被低优先级任务影响：
    - **下单线程池**
    - **推荐系统线程池**
    - **日志存储线程池**

### **📌 4. 采用异步任务处理**

- **使用消息队列（Kafka、RabbitMQ）**，将流量削峰，避免请求直接打线程池。

---

## **3️⃣ 服务器层面优化**

### **📌 1. 增加服务器实例**

- **使用负载均衡（Nginx + LVS）**，将流量分发到不同的服务器。
- **动态扩容（Kubernetes HPA / AWS Auto Scaling）**，根据流量自动增加实例。

### **📌 2. 降低 CPU 负载**

- **提高 Redis 缓存命中率**，减少数据库查询和 CPU 计算。
- **优化 GC 设置**，减少频繁 Full GC 导致的线程阻塞。

---

## **4️⃣ 结论**

| **问题**            | **解决方案**                                   |
| ----------------- | ------------------------------------------ |
| **线程池满，任务排队**     | 增加 `maximumPoolSize`，使用 `CallerRunsPolicy` |
| **非核心业务影响主业务**    | 业务线程池隔离，非核心业务降级                            |
| **高并发请求冲击系统**     | 限流（令牌桶、漏桶），缓存优化                            |
| **CPU 负载高，服务器变慢** | Redis 缓存热点数据，优化 GC，增加服务器                   |

🚀 **合理优化线程池，使用限流、缓存、异步处理，高效应对流量激增！🔥**

# 39. 线上 CPU 突然飙升的定位方案

当线上系统出现 **CPU 突然飙升**，需要快速分析 **是系统层面的问题，还是应用层面的问题**，并采取合适的排查手段。

---

## **1️⃣ 监控 CPU 状态，确定问题范围**

### **📌 1. 观察整体 CPU 负载**

- **查看 CPU 使用率**，确定是否是**单个应用引起的，还是整个系统负载异常**。
- **区分 `用户态 CPU`（us）与 `内核态 CPU`（sy）**：
    - **用户态高（us）** → 说明 CPU 主要用于**计算任务、死循环、线程池任务过载**。
    - **内核态高（sy）** → 可能是**大量线程切换、I/O 争用、系统调用过多**。

### **📌 2. 观察 CPU 核心占用情况**

- 如果 **某些 CPU 核心占用异常高**，可能是**单线程计算密集任务**或 **线程调度不均**。

### **📌 3. 监控进程占用**

- **找到占用 CPU 最高的进程**，判断是 Java 进程（JVM）还是其他进程（如数据库、Nginx）。
- **如果多个进程同时高负载**，可能是外部流量冲击或系统资源不足。

---

## **2️⃣ 确定是 Java 线程问题，还是系统资源问题**

### **📌 1. 判断是否是 Java 应用引起**

- 如果 Java 进程占用 CPU **持续过高**，可能是：
    - **计算任务异常**（死循环、高 CPU 运算）。
    - **线程池过载**（创建了大量线程）。
    - **GC 频繁触发**（Full GC 占用 CPU）。

### **📌 2. 判断是否是系统资源问题**

- **CPU 负载是否异常高**，但 Java 进程正常 → 可能是**I/O 争用、磁盘写入过载**。
- **检查网络请求数量**，是否有外部大流量攻击导致 CPU 负载升高。

---

## **3️⃣ 进一步分析 Java 进程内部情况**

### **📌 1. 查找高 CPU 消耗的 Java 线程**

- **是否有某些线程 CPU 占用异常高？**
    - **线程池过载**：创建了大量线程，导致 CPU 资源耗尽。
    - **死循环线程**：某些任务陷入无限计算，导致 CPU 长时间占用。
    - **锁竞争（大量 `BLOCKED` 线程）**：多个线程争夺锁，导致 CPU 处理效率下降。

### **📌 2. 分析 GC 是否异常**

- **如果 GC 频繁触发（Full GC）**：
    - 可能是 **内存泄漏** 或 **对象创建太快，导致垃圾回收压力大**。
    - **CPU 时间被 GC 线程占用**，导致应用性能下降。

---

## **4️⃣ 可能的 CPU 飙升原因与优化方向**

|**问题类别**|**可能原因**|**优化方案**|
|---|---|---|
|**计算密集型任务**|死循环、高 CPU 运算|代码优化，减少不必要计算|
|**线程池过载**|线程池创建大量线程|限制最大线程数，优化任务队列|
|**锁竞争严重**|大量 `BLOCKED` 线程等待锁|细化锁粒度，使用 `tryLock()` 避免死锁|
|**GC 过于频繁**|Full GC 触发太频繁|调整 GC 策略，优化堆内存|
|**突发流量冲击**|高并发请求导致 CPU 负载高|限流、缓存优化、扩容|
|**I/O 过载**|磁盘、网络请求占用 CPU 资源|优化 I/O 操作，减少同步阻塞|

---

## **5️⃣ 结论**

- **先监控整体 CPU 负载，判断是 Java 进程问题，还是系统资源问题**。
- **如果是 Java 线程导致**，排查是否是**计算任务、线程池、锁竞争、GC 过载**。
- **如果是系统资源问题**，关注**I/O 争用、流量冲击、磁盘负载**。
- **优化策略包括代码优化、线程池调优、GC 调整、流量限流、负载均衡等**。

🚀 **合理监控与优化，保障线上系统稳定运行！🔥**

# 40. 线程和进程的区别

## **1️⃣ 什么是进程和线程？**

- **进程（Process）** 是 **操作系统分配资源的基本单位**，代表一个独立运行的程序实例，拥有自己的 **内存空间、文件句柄、CPU 资源**。
- **线程（Thread）** 是 **CPU 调度的基本单位**，是进程内的执行单元，多个线程共享**同一个进程的资源**，但可以并行执行任务。

---

## **2️⃣ 线程 vs 进程 的核心区别**

|**对比项**|**进程（Process）**|**线程（Thread）**|
|---|---|---|
|**定义**|独立运行的程序实例|进程内部的执行单元|
|**资源占用**|拥有独立的 **地址空间、文件、内存、数据**|共享进程的**地址空间、文件、数据**|
|**通信方式**|进程间通信（IPC，如管道、消息队列、共享内存）**开销大**|线程间通信 **无需 IPC，直接共享内存**，更快|
|**创建销毁**|创建和销毁 **成本高**（需要分配内存、初始化资源）|线程创建**比进程轻量**，开销小|
|**切换开销**|进程切换 **需要切换内存页表、CPU 缓存**，开销大|线程切换 **共享地址空间**，开销小|
|**独立性**|进程崩溃不会影响其他进程|**线程崩溃可能导致整个进程崩溃**|
|**并发能力**|进程间并行执行，适合多核 CPU 任务|线程更轻量级，适合高并发任务|
|**使用场景**|适用于 **多进程架构，如数据库、浏览器、微服务**|适用于 **高并发场景，如 Web 服务器、计算任务**|

---

## **3️⃣ 线程和进程的应用场景**

|**场景**|**适合使用进程还是线程？**|
|---|---|
|**Web 服务器（如 Tomcat）**|线程（多个请求共享进程资源）|
|**数据库（如 MySQL）**|进程（多进程并行处理查询）|
|**大型计算任务（如 AI 训练）**|多进程（分布式计算，充分利用多核）|
|**爬虫（批量请求数据）**|多线程（IO 密集型任务）|
|**浏览器（Chrome）**|多进程（独立页面，防止崩溃）|

---

## **4️⃣ 结论**

- **进程是更独立的执行单元，线程是更轻量级的执行单元**。
- **线程切换比进程切换快，适用于高并发任务**。
- **进程间隔离性更强，适用于大型分布式应用**。

# 41. 并行 vs 并发

## **1️⃣ 定义**

- **并行（Parallelism）**：多个任务**同时执行**，通常发生在**多核 CPU** 上，多个任务真正**同时运行**。
- **并发（Concurrency）**：多个任务**在同一时间段内交替执行**，它们**可能不是真的同时运行**，而是**任务快速切换**，让用户感觉像是同时进行。

---

## **2️⃣ 核心区别**

|**对比项**|**并行（Parallelism）**|**并发（Concurrency）**|
|---|---|---|
|**执行方式**|**真正同时运行**多个任务|**任务交替运行**，在 CPU 上快速切换|
|**依赖的硬件**|需要**多核 CPU**，不同任务**同时运行**|单核 CPU 也能并发，但不是同时运行|
|**任务关系**|任务之间**相互独立**，可以并行处理|任务**可能有依赖关系**，需要协调调度|
|**示例**|多线程计算 AI 任务，多核 CPU 处理多个任务|多个 Web 请求处理，线程池切换任务|
|**适用场景**|计算密集型任务，如**深度学习、视频渲染**|高并发 Web 服务器，如**Nginx 处理请求**|

---

## **3️⃣ 直观理解**

- **并行**：**多个厨师同时做菜**，每个人负责一道菜。
- **并发**：**一个厨师在多个菜之间切换**，一会炒菜，一会煮汤，看起来像是同时做饭，但实际上是**快速切换**。

---

## **4️⃣ 结论**

- **并行是“真正同时运行”，并发是“任务交替执行”**。
- **多核 CPU 支持并行，单核 CPU 也能实现并发**。
- **并行适用于计算密集型任务，并发适用于高吞吐业务，如 Web 服务器、数据库查询**。

# 42. 常用的 JDK 版本及特点

## **1️⃣ JDK 版本发展概览**

Java 主要由 **Oracle JDK** 和 **OpenJDK** 维护，每个版本**都有 LTS（长期支持）和非 LTS 版本**。企业应用通常选择 **LTS 版本**，因为它们提供更长时间的安全更新和支持。

---

## **2️⃣ 常用的 JDK 版本**

### **📌 1. JDK 8（LTS，长期支持）**

- **发布时间**：2014 年 3 月
- **特点**：
    - **Lambda 表达式**：支持函数式编程，简化代码。
    - **Stream API**：高效处理集合操作。
    - **默认方法（Default Methods）**：接口支持默认实现。
    - **新日期 API（java.time）**：替代 `java.util.Date`，线程安全。
    - **GC 优化**：启用 G1 GC，提升性能。
- **适用场景**：
    - 目前仍然是**很多企业的主力版本**，稳定性高。

---

### **📌 2. JDK 11（LTS，长期支持）**

- **发布时间**：2018 年 9 月
- **特点**：
    - **HttpClient API**：支持 HTTP/2，替代 `HttpURLConnection`。
    - **ZGC（低延迟 GC）**：减少 GC 停顿时间。
    - **JEP 328**：Flight Recorder，低开销的 Java 监控工具。
    - **移除 `java.xml.ws`、`java.xml.bind` 等过时 API**。
    - **`var` 关键字增强**（局部变量类型推断）。
- **适用场景**：
    - 适用于**生产环境**，企业可长期维护。

---

### **📌 3. JDK 17（LTS，长期支持）**

- **发布时间**：2021 年 9 月
- **特点**：
    - **G1/ZGC 改进**：进一步优化垃圾回收性能。
    - **Sealed Classes（密封类）**：控制子类继承权限。
    - **Switch 表达式增强**：简化代码结构。
    - **模式匹配（Pattern Matching）**：提升 `instanceof` 可读性。
    - **Foreign Function & Memory API（预览版）**：优化非 Java 代码调用。
- **适用场景**：
    - 推荐**新项目直接使用 JDK 17**，LTS 支持更久，性能更优。

---

### **📌 4. JDK 21（LTS，最新长期支持）**

- **发布时间**：2023 年 9 月
- **特点**：
    - **虚拟线程（Virtual Threads）**：极大提升并发处理能力。
    - **模式匹配增强**：支持 `switch` 模式匹配，提高可读性。
    - **记录模式（Record Patterns）**：用于模式解构，提高代码简洁度。
    - **GC 改进**：增强 G1/ZGC，减少延迟。
    - **结构化并发 API（Structured Concurrency）**：优化线程管理。
- **适用场景**：
    - 未来新项目**优先采用 JDK 21**，提供长期支持（LTS）。

---

## **3️⃣ JDK 版本选择建议**

|**JDK 版本**|**LTS 支持**|**适用场景**|
|---|---|---|
|**JDK 8**|✅（老 LTS）|仍广泛用于老项目，稳定可靠，但部分特性落后|
|**JDK 11**|✅（LTS）|适合生产环境，提供长期支持，性能优化明显|
|**JDK 17**|✅（LTS）|企业新项目首选，性能更优|
|**JDK 21**|✅（最新 LTS）|推荐未来新项目采用，支持虚拟线程，提升并发性能|

---

## **4️⃣ 结论**

- **JDK 8** 仍然广泛使用，但**JDK 11 以上版本提供了更好的性能和新特性**。
- **JDK 17** 是目前**最佳选择**，支持 LTS，稳定性高。
- **JDK 21** 是**最新 LTS**，如果项目可以接受新特性，建议直接升级。

# 43. Object 创建过程中内存的分配过程

## **1️⃣ Object 创建的整体流程**

当 Java 程序创建一个对象时，JVM 需要完成**对象的内存分配、初始化和引用赋值**，整个过程包括以下几个阶段：

1. **类加载检查**：JVM 检查类是否已加载，若未加载，则先进行类加载。
2. **内存分配**：在堆（Heap）上分配内存空间，确保对象可以存储实例变量和对象头。
3. **内存地址填充**：处理并发安全问题（TLAB 或 CAS 机制）。
4. **对象初始化**：
    - 默认初始化（成员变量赋默认值）
    - 显式初始化（赋值语句、构造方法执行）
    - 对象头信息填充（哈希值、GC 信息）
5. **对象引用赋值**：将对象的内存地址赋给变量，完成对象创建。

---

## **2️⃣ 详细的内存分配流程**

### **📌 1. 类加载检查**

- 在创建对象之前，JVM **检查类的元数据**（Class Metadata）是否已加载到 **方法区（Method Area）**。
- 若未加载，则 **触发类加载机制**，执行 **类的 `<clinit>` 方法**（静态变量 & 代码块初始化）。

---

### **📌 2. 在堆上分配内存**

对象存储在 **堆（Heap）**，JVM 采用以下两种方式分配内存：

- **指针碰撞（Bump-the-Pointer）**（当堆是规整的）
    - JVM 只需移动一个指针，快速分配内存，适用于 **Serial GC、G1 GC**。
- **空闲列表（Free List）**（当堆存在内存碎片）
    - 通过 **查找空闲块** 进行内存分配，适用于 **CMS GC**（可能导致碎片化）。

---

### **📌 3. 处理并发安全问题**

当多个线程创建对象时，需要**保证分配的对象内存不冲突**，JVM 采用：

- **TLAB（Thread Local Allocation Buffer）**：
    - **为每个线程预分配一小块堆内存**，避免竞争，提高分配效率。
- **CAS + 失败重试**：
    - 采用 **Compare And Swap（CAS）** 确保分配过程的原子性。

---

### **📌 4. 初始化对象**

对象初始化过程分为**三个阶段**：

1. **默认初始化**：
    - JVM **将对象的所有成员变量初始化为默认值**（如 `int=0`，`boolean=false`）。
2. **显式初始化**：
    - **执行构造方法前的字段赋值**，如 `int a = 10;`。
3. **构造方法执行**：
    - 执行**构造器 `super()` 调用父类初始化**，然后执行自身构造方法。

---

### **📌 5. 对象引用赋值**

- **对象创建完成后，JVM 将对象地址赋给引用变量**，让外部可以访问该对象。

---

## **3️⃣ 结论**

- **Java 对象创建时，JVM 在堆上分配内存，并执行初始化**。
- **使用 TLAB 机制优化多线程分配，避免并发冲突**。
- **通过指针碰撞或空闲列表进行高效内存管理**。
- **完整初始化后，JVM 才会返回对象引用，供程序使用**。

# 44. 引用存放位置

在 Java 运行时，**对象的引用和对象本身存储位置不同**：

- **对象（实例）存储在** **堆（Heap）** 中。
- **对象引用存储在** **栈（Stack）** 中。

---

## **1️⃣ 栈（Stack）中的引用存放位置**

- **栈是线程私有的**，每个线程都有自己的 **虚拟机栈**，用于存放**方法调用的局部变量、对象引用、方法返回地址**等信息。
- 当创建对象时：
    1. **对象本身存放在堆内存（Heap）**。
    2. **对象的引用（Reference）存放在栈内存（Stack）**。

**示例解析**：

`Person p = new Person();`

- `p` **存储在栈中**，指向堆中的 `Person` 对象。
- `new Person()` **创建的对象存储在堆中**。

---

## **2️⃣ 多种引用存放位置**

### **📌 1. 局部变量引用**

- **存放在当前方法的栈帧（Stack Frame）中**，方法执行完后释放。

`void test() {     Person p = new Person(); } // 方法执行结束，p 被回收`

### **📌 2. 成员变量引用**

- **存放在对象的实例变量中，而对象本身在堆上**。

`class Person {     String name; // name 引用存储在堆中（Person 对象内） }`

- `name` 这个引用本身存放在 `Person` 对象的 **堆内存** 里。

### **📌 3. 静态变量引用**

- **存放在方法区（JDK 8+ 为 Metaspace），对象仍然存储在堆中**。

`class Person {     static Person instance = new Person(); }`

- `instance` 这个引用存储在 **方法区（Metaspace）**，但对象仍然在 **堆内存**。

---

## **3️⃣ 结论**

|**引用类型**|**存储位置**|**对象存储位置**|
|---|---|---|
|**局部变量引用**|**栈（方法栈帧）**|**堆**|
|**实例变量引用**|**堆（对象内部）**|**堆**|
|**静态变量引用**|**方法区（JDK 8+ Metaspace）**|**堆**|

# 45. ThreadLocal 的使用与原理

## **1️⃣ 什么是 ThreadLocal？**

`ThreadLocal` 是 Java 提供的 **线程局部变量（Thread-Scoped Variables）**，它允许每个线程拥有**自己独立的变量副本**，**不同线程之间的数据相互隔离**。

**特点：**

- 每个线程访问 `ThreadLocal` 时，**只能读取 & 修改自己的变量副本**，不会影响其他线程。
- 适用于**存储线程私有数据**，如 **用户会话、事务管理、连接池等**。

---

## **2️⃣ ThreadLocal 的核心特点**

|**特性**|**描述**|
|---|---|
|**线程隔离**|每个线程有独立变量，互不影响|
|**避免锁竞争**|线程独享数据，不需要加锁（无竞争）|
|**生命周期管理**|变量随线程生命周期结束自动清理|
|**适用于**|**用户会话、数据库连接、事务管理**|

---

## **3️⃣ ThreadLocal 的使用场景**

|**应用场景**|**作用**|
|---|---|
|**用户会话（Session）**|**存储当前请求的用户信息**，避免多线程共享数据冲突|
|**数据库连接（JDBC）**|**为每个线程分配独立的 DB 连接**，避免连接共享问题|
|**事务管理（Transaction）**|**存储事务对象，避免并发事务混乱**|
|**日志追踪（Tracing）**|**在整个调用链中存储 TraceID，方便日志追踪**|

---

## **4️⃣ ThreadLocal 工作原理**

### **📌 1. 结构解析**

- **每个线程（Thread）** 持有一个 **ThreadLocalMap**（线程私有的 Map）。
- **ThreadLocal 变量作为 key，存储在线程的 ThreadLocalMap 中**。

### **📌 2. 数据存储过程**

1. 线程调用 `ThreadLocal.set(value)`：
    - **在当前线程的 ThreadLocalMap 中存入 `value`**。
2. 线程调用 `ThreadLocal.get()`：
    - **从当前线程的 ThreadLocalMap 读取 `value`**。

🔹 **示例：**

- `thread1.set("UserA")` → 线程 1 的 `ThreadLocalMap` 存 `"UserA"`
- `thread2.set("UserB")` → 线程 2 的 `ThreadLocalMap` 存 `"UserB"`

**两个线程互不影响！**

---

## **5️⃣ ThreadLocal 可能导致的内存泄漏**

### **📌 1. 内存泄漏的原因**

- `ThreadLocalMap` **使用弱引用（WeakReference）** 存储 key（ThreadLocal）。
- 但**Value 仍然是强引用**，如果**ThreadLocal 被 GC 回收**，但**线程仍然存活**，就会导致 **Value 无法自动回收，发生内存泄漏**。

### **📌 2. 解决方案**

|**优化策略**|**作用**|
|---|---|
|**手动清理** `ThreadLocal.remove()`|防止线程池复用时数据残留|
|**使用 `try-finally`**|在 `finally` 代码块中移除数据|
|**避免存储大对象**|减少内存占用|

---

## **6️⃣ ThreadLocal vs. 线程同步（synchronized）**

|**对比项**|**ThreadLocal**|**synchronized**|
|---|---|---|
|**作用**|线程私有变量|线程间共享变量|
|**是否需要锁**|**不需要锁**（每个线程独立）|**需要加锁**，保证可见性|
|**数据访问方式**|**每个线程拥有独立变量**|**多个线程共享变量**|
|**适用场景**|**线程安全的局部变量存储**|**多线程共享数据的同步**|

---

## **7️⃣ 结论**

- **ThreadLocal 适用于线程私有变量**，每个线程独立存储，不会互相影响。
- **适用于用户会话、事务管理、数据库连接等场景**，避免锁竞争，提高并发性能。
- **必须手动 `remove()` 清理，防止线程池复用导致的内存泄漏**。

# 46. ThreadLocal 何时调用 `remove()`？

`ThreadLocal.remove()` 主要用于**防止内存泄漏**，尤其在使用**线程池**时，线程会被**复用**，如果不手动清理，**旧数据可能被下一个任务误用**。

---

## **1️⃣ 为什么需要 `remove()`？**

### **📌 1.1 ThreadLocal 可能导致的内存泄漏**

- **`ThreadLocalMap` 绑定在线程对象上**，线程不结束，数据就不会释放。
- **ThreadLocal 作为 Key 是弱引用**，但 **Value 仍然是强引用**，如果 ThreadLocal 被回收，Value 可能无法释放，导致**内存泄漏**。

🔹 **示例（可能的内存泄漏）**

|**线程**|**ThreadLocal Key**|**Value**|
|---|---|---|
|线程 A|❌（GC 回收）|✅ **仍然存在**（无法释放）|

---

## **2️⃣ 什么时候需要 `remove()`？**

### **📌 2.1 线程池环境**

- **线程池会复用线程**，如果不 `remove()`，旧线程的数据会污染新任务的环境。
- **解决方案**：任务结束后，手动 `remove()`。

### **📌 2.2 长生命周期的线程**

- **长时间运行的线程（如 Netty、RPC 线程）**，如果不 `remove()`，`ThreadLocalMap` 数据会一直存在，导致**内存占用增加**。

### **📌 2.3 事务管理**

- **Spring 事务管理可能使用 `ThreadLocal`** 存储事务信息，事务结束后需要**手动清理**。

---

## **3️⃣ 最佳实践：如何正确 `remove()`**

### **📌 3.1 在 `finally` 代码块中清理**

**避免因为异常导致 `remove()` 没有执行**

### **📌 3.2 在线程池执行任务时**

任务执行完后，**确保 `remove()` 释放内存**。

### **📌 3.3 在 Spring AOP 中清理**

**Spring 事务管理等场景**，在 `@After` 方式清理：

---

## **4️⃣ 结论**

|**场景**|**是否需要 `remove()`？**|**原因**|
|---|---|---|
|**普通请求（非线程池）**|❌ 可自动回收|线程结束后自动释放|
|**线程池（如 Tomcat 线程池）**|✅ 必须 `remove()`|线程复用，避免数据污染|
|**长生命周期线程（如 Netty）**|✅ 必须 `remove()`|避免 `ThreadLocalMap` 占用内存|
|**事务管理（Spring AOP）**|✅ 推荐 `remove()`|确保事务隔离|

🚀 **在高并发系统中，正确使用 `remove()`，防止线程池复用导致的内存泄漏！🔥**

# 47. Java 四种引用类型（强引用、软引用、弱引用、虚引用）

Java 提供了 **四种不同级别的引用类型**，用于**控制对象的生命周期**，优化垃圾回收（GC），避免内存泄漏。

---

## **1️⃣ 强引用（Strong Reference）**

### **📌 1.1 定义**

- **最常见的引用类型**，对象只要有强引用存在，就不会被 GC 回收。
- 只有当**对象没有任何强引用时，才会被垃圾回收**。

### **📌 1.2 特点**

|**特点**|**说明**|
|---|---|
|**不会被 GC 回收**|只有当 `null` 赋值时，才会被 GC 清理|
|**对象始终存活**|适用于**重要对象（如业务数据、单例对象）**|
|**可能导致内存泄漏**|若不手动清理，GC 不会回收，可能导致 OOM|

### **📌 1.3 适用场景**

- **普通对象、业务逻辑对象**
- **单例模式对象**
- **缓存中必须持久存活的对象**

---

## **2️⃣ 软引用（Soft Reference）**

### **📌 2.1 定义**

- **对象只有软引用时，JVM 在内存不足（OOM 前）才会回收它**。
- 适用于**缓存**，当系统**内存紧张**时，**自动释放内存**，防止 OOM。

### **📌 2.2 特点**

|**特点**|**说明**|
|---|---|
|**可能被 GC 回收**|只有内存不足时，才会清理软引用对象|
|**适合缓存数据**|适用于**缓存数据、图片、数据库连接**|
|**避免 OOM**|JVM 先清理软引用对象，而不是抛出 OOM|

### **📌 2.3 适用场景**

- **缓存数据**（如**图片缓存、数据库查询结果**）
- **避免 OOM，提升 JVM 性能**

---

## **3️⃣ 弱引用（Weak Reference）**

### **📌 3.1 定义**

- **对象只有弱引用时，GC 发现它就会立即回收**，无论**内存是否充足**。
- 适用于**临时对象、避免内存泄漏**。

### **📌 3.2 特点**

|**特点**|**说明**|
|---|---|
|**被 GC 发现就回收**|即使内存充足，GC 也会清理|
|**防止内存泄漏**|适用于**缓存、弱引用 Map**|
|**适合监听器模式**|避免注册对象无法释放，导致内存泄漏|

### **📌 3.3 适用场景**

- **WeakHashMap**（用于缓存，GC 后自动删除 Key）
- **监听器（如 Event 监听器）**，避免手动清理对象
- **临时对象，防止占用过多内存**

---

## **4️⃣ 虚引用（Phantom Reference）**

### **📌 4.1 定义**

- **虚引用对象永远不会影响 GC**，仅用于**检测对象何时被回收**。
- **必须与 `ReferenceQueue` 配合使用**，在对象被 GC 回收时，可以触发**后续清理操作**（如关闭资源）。

### **📌 4.2 特点**

|**特点**|**说明**|
|---|---|
|**永远无法通过 `get()` 访问对象**|仅用于监听对象是否被回收|
|**必须与 `ReferenceQueue` 结合**|触发**资源释放、日志记录**|
|**适用于 JVM 资源管理**|用于**大对象、文件、数据库连接释放**|

### **📌 4.3 适用场景**

- **监控对象是否被回收**，触发资源释放（如 DirectByteBuffer 内存管理）
- **JVM 垃圾回收跟踪**，监控对象销毁时机
- **清理大对象**，如大内存块、文件流

---

## **5️⃣ 四种引用类型对比**

|**引用类型**|**GC 回收条件**|**存活时间**|**典型应用**|
|---|---|---|---|
|**强引用（Strong Reference）**|**永远不会被回收**|**除非主动置为 null**|普通对象、业务数据|
|**软引用（Soft Reference）**|**内存不足时才会回收**|**可能存活较长时间**|缓存（如图片、数据库查询结果）|
|**弱引用（Weak Reference）**|**GC 发现就会回收**|**短暂存活**|缓存（如 WeakHashMap）|
|**虚引用（Phantom Reference）**|**对象被 GC 时，触发回调**|**最短，主要用于 GC 监听**|资源释放（如 DirectByteBuffer）|

---

## **6️⃣ 选择合适的引用类型**

|**需求**|**推荐引用类型**|
|---|---|
|**对象必须始终存活，不可回收**|**强引用**|
|**缓存，避免 OOM，但尽量保留数据**|**软引用**|
|**临时对象，GC 发现立即回收**|**弱引用**|
|**监控对象何时被回收，触发清理任务**|**虚引用**|

🚀 **合理使用引用类型，优化内存管理，提高 GC 效率！🔥**

# 48. String vs. StringBuffer vs. StringBuilder 对比

在 Java 中，`String`、`StringBuffer` 和 `StringBuilder` 都可以用于**字符串操作**，但它们的**可变性、线程安全性和性能**存在重要区别。

---

## **1️⃣ 三者的核心区别**

|**对比项**|**String（不可变）**|**StringBuffer（线程安全，可变）**|**StringBuilder（非线程安全，可变）**|
|---|---|---|---|
|**是否可变**|❌ **不可变**（`final char[]`）|✅ **可变**（`char[]`，线程安全）|✅ **可变**（`char[]`，非线程安全）|
|**线程安全**|✅ 线程安全（因为不可变）|✅ **线程安全**（同步 `synchronized`）|❌ **非线程安全**|
|**性能**|❌ **低**（每次拼接创建新对象）|❌ **中等**（`synchronized` 有性能开销）|✅ **高**（无同步开销，适合单线程）|
|**适用场景**|少量字符串操作（适用于**字符串池**、HashMap Key）|**多线程**下的字符串拼接|**单线程**高频字符串拼接|
|**底层实现**|`final char[]`（不可变）|**可变 `char[]`，线程安全**|**可变 `char[]`，但不加锁**|

---

## **2️⃣ String（不可变）**

### **📌 2.1 主要特性**

- `String` **是不可变的**，每次修改都会创建**新的对象**。
- 适用于**少量字符串操作、存储不可变数据（如 HashMap Key）**。

### **📌 2.3 适用场景**

- **字符串内容不会频繁修改**
- **适用于常量池优化（String Pool）**
- **适用于 HashMap Key**
- **适用于多线程环境（无需同步）**

---

## **3️⃣ StringBuffer（可变，线程安全）**

### **📌 3.1 主要特性**

- **`StringBuffer` 是可变的**，修改时不会创建新对象。
- **线程安全**，所有方法都被 `synchronized` 修饰。

### **📌 3.3 适用场景**

- **多线程环境**（需要同步）
- **高频字符串拼接，但需要线程安全**

---

## **4️⃣ StringBuilder（可变，非线程安全）**

### **📌 4.1 主要特性**

- **`StringBuilder` 是 `StringBuffer` 的非线程安全版本**，但性能更高。
- 适用于**单线程环境**的字符串拼接。
- **和 `StringBuffer` 相同，但不加锁，性能更高。**

### **📌 4.3 适用场景**

- **单线程环境，高性能字符串拼接**
- **需要大量字符串修改的场景**

---

## **5️⃣ 三者性能对比**

|**操作**|**String**|**StringBuffer**|**StringBuilder**|
|---|---|---|---|
|**拼接 10000 次**|**慢（创建新对象）**|**中等（加锁影响性能）**|**最快（无锁）**|
|**单线程环境**|适用（但低效）|可用（但 `StringBuilder` 更优）|**最优**|
|**多线程环境**|适用（不可变，线程安全）|**最佳（加锁，线程安全）**|❌ 不适用|

---

## **6️⃣ 什么时候使用哪种？**

|**使用场景**|**推荐使用**|
|---|---|
|**少量字符串操作，内容不会变**|**`String`（不可变，适合缓存池）**|
|**多线程，高并发环境**|**`StringBuffer`（线程安全）**|
|**单线程，大量拼接操作**|**`StringBuilder`（最高性能）**|

🚀 **合理选择 `String`、`StringBuffer`、`StringBuilder`，提升性能，提高代码质量！🔥**

# 49. 为什么 `String` 设计为 `final` 修饰？

在 Java 中，`String` 是 **不可变（Immutable）** 的，它的 `final` 修饰符**确保了不可变性**，从而带来安全性、性能优化和多线程安全等优势。

---

## **1️⃣ `final` 修饰 `String` 的作用**

1. **防止继承（final 类）**
    - `final class String` **不能被继承**，避免子类修改其行为。
2. **保证不可变性**
    - `String` **内部使用 `final char[]` 存储字符串**，保证内容不可变。

---

## **2️⃣ `String` 设计为 `final` 的核心原因**

### **📌 1. 线程安全**

- `String` 是不可变的，多个线程可以安全共享，无需加锁。

---

### **📌 2. 方便字符串常量池（String Pool）优化**

- **JVM 采用字符串常量池优化**，相同字符串**复用**，减少对象创建。
- **示例**：

```
String s1 = "Hello";
String s2 = "Hello"; // 复用 s1，减少内存占用
System.out.println(s1 == s2); // true
```

- **如果 `String` 可变**，修改 `s1` 会影响 `s2`，破坏字符串池机制。

---

### **📌 3. 作为 HashMap Key，保证哈希一致**

- `String` 作为 `HashMap` 的 `Key` 时，`final` 确保 `hashCode` **不会变化**。
- **示例**：
```
Map<String, Integer> map = new HashMap<>();
map.put("Alice", 25);
```
- **如果 `String` 可变，修改 Key 会导致 `get()` 失败！**

---

### **📌 4. 安全性（防止篡改）**

- `String` 常用于 **用户名、密码、数据库 URL**，`final` 避免修改带来的安全问题。
- **如果 `String` 可变，恶意代码可能篡改 URL，导致数据库被攻击！**

---

### **📌 5. `final` 避免继承，防止行为修改**

- **如果 `String` 允许继承，子类可能篡改 `equals()` 或 `hashCode()`，破坏一致性。**
- **示例（不允许继承）：**
- **如果 `String` 可继承，可能导致不安全的子类重写方法，影响 JVM 运行。**

---

## **3️⃣ 结论**

|**原因**|**作用**|
|---|---|
|**线程安全**|不可变对象，多个线程可共享|
|**支持字符串池优化**|`String` 复用，减少内存占用|
|**保证哈希一致性**|`HashMap` Key 不变，避免数据丢失|
|**增强安全性**|防止篡改数据库 URL、密码|
|**防止继承破坏行为**|`final` 避免子类修改 `hashCode`|

# 50. 注解原理详解

## **1️⃣ 什么是 Java 注解（Annotation）？**

Java **注解（Annotation）** 是一种**元数据**，用于给**类、方法、字段、参数**等添加**额外信息**，可用于**编译期处理、运行时反射**等。注解本身不会影响代码逻辑，而是用于**标记和解析**。

---

## **2️⃣ 注解的分类**

|**类别**|**特点**|**示例**|
|---|---|---|
|**编译期注解**|只在编译期生效，不影响运行时|`@Override`、`@Deprecated`|
|**运行时注解**|运行时可通过**反射**解析|`@Autowired`、`@Transactional`|
|**元注解**|用于定义其他注解|`@Retention`、`@Target`|

---

## **3️⃣ 注解的底层原理**

### **📌 3.1 注解的本质**

- **注解是继承自 `java.lang.annotation.Annotation` 接口的特殊接口**。
- **底层是 Java 反射机制**，通过 `Class.getAnnotations()` 获取注解信息。

---

### **📌 3.2 注解的生命周期（`@Retention`）**

|**注解生命周期**|**作用**|**示例**|
|---|---|---|
|`SOURCE`|**仅在编译期生效**，不会保留到 `.class`|`@Override`、`@SuppressWarnings`|
|`CLASS`|**存储在 `.class` 文件中**，但运行时不可获取|`@Autowired`（Spring 处理）|
|`RUNTIME`|**运行时可通过反射获取**，用于框架解析|`@Transactional`、`@Service`|

---

### **📌 3.3 注解的作用范围（`@Target`）**

|**作用范围**|**说明**|**示例**|
|---|---|---|
|`TYPE`|作用于 **类、接口、枚举**|`@Component`|
|`METHOD`|作用于 **方法**|`@GetMapping`|
|`FIELD`|作用于 **成员变量**|`@Autowired`|
|`PARAMETER`|作用于 **方法参数**|`@RequestParam`|
|`CONSTRUCTOR`|作用于 **构造方法**|`@Autowired`|

---

### **📌 3.4 解析运行时注解（反射）**

运行时注解的底层原理是 **Java 反射**，通过 `Class` 解析：

1. **获取类的 `Class` 对象**
2. **调用 `getAnnotation(Class<T>)` 获取注解**
3. **解析注解信息**

---

## **4️⃣ 注解处理机制**

### **📌 4.1 运行时注解解析**

框架（如 Spring、MyBatis）会**通过反射**读取注解，并执行相应的逻辑：

```
Class<?> clazz = UserService.class;
if (clazz.isAnnotationPresent(Service.class)) {
    System.out.println("UserService 被标记为 @Service");
}
```

---

### **📌 4.2 编译期注解（APT 处理器）**

编译期注解（`@Component`、`@Entity`）可以借助 **Java APT（Annotation Processing Tool）** 在编译时**生成代码**。

**APT 处理器原理：**

1. **编译器发现注解**
2. **调用 `Processor` 进行代码分析**
3. **动态生成 `.class` 或 `.java` 文件**
4. **编译器继续处理新的代码**

🔹 **示例（APT 处理器）**

```
@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MyAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // 处理注解逻辑
        return true;
    }
}
```

**作用**：用于**自动代码生成（如 Lombok、Dagger、ButterKnife）**。

---

## **5️⃣ 框架如何使用注解**

|**框架**|**使用注解**|**解析方式**|
|---|---|---|
|**Spring**|`@Component`、`@Autowired`|反射 (`Class.forName`)|
|**Spring Boot**|`@EnableAutoConfiguration`|反射 + SPI 机制|
|**JPA**|`@Entity`、`@Table`|反射 + APT|
|**MyBatis**|`@Mapper`、`@Select`|运行时解析|

---

## **6️⃣ 结论**

1. **注解是 Java 的元数据，主要用于标记和反射解析**。
2. **`@Retention` 决定生命周期，`@Target` 决定作用范围**。
3. **运行时注解可以通过反射解析（Spring、MyBatis 依赖）**。
4. **编译期注解可用于 APT 自动生成代码（Lombok、Dagger）**。
5. **框架通过注解管理 Bean、AOP、数据库映射，提高开发效率**。

# 51. `Atomic` 原子类详解

Java **`Atomic` 原子类** 是 **基于 CAS（Compare-And-Swap，比较交换）** 机制实现的 **无锁并发** 解决方案。它提供 **线程安全** 的 **原子操作**，避免使用 `synchronized` 造成的性能开销。

---

## **1️⃣ 什么是 `Atomic` 原子类？**

- **`Atomic` 系列类提供了基本数据类型的原子操作，支持并发环境下的安全修改。**
- **基于 CAS 机制**（无需加锁 `synchronized`）。
- **适用于高并发计数、状态更新、无锁操作。**

---

## **2️⃣ `Atomic` 类的分类**

`Atomic` 包含 **四大类原子操作**：

|**类别**|**常见类**|**作用**|
|---|---|---|
|**基本类型原子操作**|`AtomicInteger`、`AtomicLong`、`AtomicBoolean`|适用于 **int、long、boolean** 变量的原子操作|
|**数组元素原子操作**|`AtomicIntegerArray`、`AtomicLongArray`|适用于 **数组元素** 的原子更新|
|**对象引用原子操作**|`AtomicReference<T>`、`AtomicStampedReference`|适用于 **对象引用** 的原子更新|
|**字段更新原子操作**|`AtomicIntegerFieldUpdater`、`AtomicLongFieldUpdater`|**用于对象字段的原子修改**|

---

## **3️⃣ `Atomic` 原子类的底层原理**

### **📌 3.1 `Atomic` 原子类基于 CAS 机制**

- **CAS（Compare-And-Swap）**：比较并交换，是 **一种无锁算法**。
- **核心思想**：
    1. 读取当前值 **V**。
    2. 计算新值 **N**。
    3. **使用 `CAS(V, Expected, N)` 比较当前值 `V` 是否等于 `Expected`**：
        - **相等** → 说明没有其他线程修改，**更新成功**。
        - **不相等** → 说明发生并发冲突，**重试（自旋）**。

🔹 **JDK 底层使用 `Unsafe` 类 + CPU 指令（`cmpxchg`） 实现 CAS 操作**：

- `compareAndSwapInt` 是 **CPU 级别的 CAS 指令**，实现原子操作。

---

## **4️⃣ 常见 `Atomic` 类**

### **📌 4.1 `AtomicInteger`（原子整数）**

适用于 **高并发计数**，如访问量统计、线程计数。

🔹 **示例**
```
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // +1
count.getAndAdd(5);      // +5
System.out.println(count.get()); // 获取值

```
🔹 **常用方法**

|**方法**|**作用**|
|---|---|
|`incrementAndGet()`|**自增 +1**（返回新值）|
|`decrementAndGet()`|**自减 -1**（返回新值）|
|`addAndGet(int delta)`|**加指定值**|
|`getAndSet(int newValue)`|**设置新值并返回旧值**|
|`compareAndSet(int expect, int update)`|**CAS 更新值**|

---

### **📌 4.2 `AtomicReference<T>`（原子引用）**

适用于 **保证对象引用的原子更新**，防止并发修改对象指针。

🔹 **示例**
```
AtomicReference<String> atomicString = new AtomicReference<>("Hello");
atomicString.compareAndSet("Hello", "World");
System.out.println(atomicString.get()); // World
```
🔹 **常用方法**

|**方法**|**作用**|
|---|---|
|`get()`|获取当前对象|
|`set(T newValue)`|设置新对象|
|`compareAndSet(T expect, T update)`|CAS 更新对象|
|`getAndUpdate(UnaryOperator<T> updateFunction)`|通过函数更新对象|

---

### **📌 4.3 `AtomicStampedReference<T>`（解决 ABA 问题）**

**ABA 问题**：CAS 只比较值，可能导致 **"A → B → A" 变化被错误认为没有修改**。

- `AtomicStampedReference` **加入版本号 `stamp`**，防止 `ABA` 问题。

🔹 **示例**
```
AtomicStampedReference<Integer> atomicStamped = new AtomicStampedReference<>(100, 1);
int stamp = atomicStamped.getStamp(); // 获取版本号
atomicStamped.compareAndSet(100, 200, stamp, stamp + 1);
```
🔹 **适用于**：**避免 ABA 问题的高并发场景**（如队列、栈操作）。

---

### **📌 4.4 `AtomicIntegerArray`（原子数组）**

用于 **保证数组元素的原子性更新**，多个线程可安全修改数组值。

🔹 **示例**
```
AtomicIntegerArray array = new AtomicIntegerArray(5);
array.set(0, 10);
array.incrementAndGet(0); // 数组 index=0 元素 +1
System.out.println(array.get(0)); // 11
```
---

## **5️⃣ `Atomic` vs `synchronized`（对比）**

|**对比项**|**Atomic 原子类**|**synchronized**|
|---|---|---|
|**锁机制**|**无锁（CAS 自旋）**|**悲观锁（线程阻塞）**|
|**性能**|**高（适用于高并发）**|**低（存在上下文切换）**|
|**线程安全**|**保证单个变量线程安全**|**保证整个代码块/方法安全**|
|**适用场景**|**高并发计数、状态更新**|**复杂的共享资源管理**|

---

## **6️⃣ `Atomic` 适用场景**

|**场景**|**推荐 `Atomic` 类**|
|---|---|
|**高并发计数（访问量统计）**|`AtomicInteger` / `AtomicLong`|
|**CAS 方式更新对象引用**|`AtomicReference<T>`|
|**多线程安全的数组**|`AtomicIntegerArray`|
|**避免 ABA 问题**|`AtomicStampedReference`|

---

## **7️⃣ 结论**

1. **`Atomic` 原子类基于 CAS（无锁机制），比 `synchronized` 轻量级，适用于高并发。**
2. **适用于高并发计数、状态更新、线程安全队列等场景。**
3. **`AtomicStampedReference` 解决 `ABA` 问题，适用于并发修改的场景。**
4. **适用于单个变量的线程安全更新，复杂同步仍需 `synchronized` 或 `Lock`。**

🚀 **掌握 `Atomic` 原子类，优化并发性能，提升 Java 高并发编程能力！🔥**

# 52. GraalVM：高性能多语言虚拟机

## **1️⃣ 什么是 GraalVM？**

GraalVM 是 **Oracle 开发的高性能 Java 虚拟机**，旨在 **提升 Java 应用的运行效率**，并支持 **多语言（Java、JavaScript、Python、Ruby、C/C++ 等）** 的**互操作性**。

---

## **2️⃣ GraalVM 的核心特点**

|**特性**|**描述**|
|---|---|
|**高性能 JIT 编译**|**替换传统 HotSpot JIT 编译器**，提高 Java 代码执行效率|
|**AOT（Ahead-Of-Time）编译**|**将 Java 代码直接编译为原生二进制文件**，提升启动速度|
|**多语言支持**|**支持 Java、JavaScript、Python、Ruby、R、C、C++ 等**|
|**低内存占用**|**比传统 JVM 占用更少内存，适用于云计算 & 容器**|
|**无缝集成**|兼容 **JVM 生态（Spring Boot、Micronaut、Quarkus）**|

---

## **3️⃣ GraalVM 主要组件**

|**组件**|**作用**|
|---|---|
|**Graal JIT 编译器**|代替 **JVM 默认的 C2 JIT 编译器**，提升运行性能|
|**Native Image（AOT 编译器）**|直接**将 Java 应用编译为原生可执行文件**，减少启动时间|
|**Polyglot（多语言互操作）**|**支持多语言（Python、C、JS 等）在 JVM 上运行**|
|**Truffle API**|**用于构建动态语言解释器**，优化多语言执行|

---

## **4️⃣ GraalVM vs 传统 JVM（HotSpot）**

|**对比项**|**GraalVM**|**HotSpot JVM**|
|---|---|---|
|**编译方式**|**JIT + AOT**|**JIT（解释执行 + C2 编译器）**|
|**启动速度**|**快（AOT 编译可实现 0ms 启动）**|**慢（需要 JIT 预热）**|
|**运行效率**|**更快（优化 JIT 编译）**|**较快（传统优化）**|
|**内存占用**|**低（无需完整 JVM 运行时）**|**较高（JVM 运行时开销大）**|
|**多语言支持**|**支持 Java、JS、Python、C++ 等**|**仅支持 Java & JVM 语言**|

---

## **5️⃣ GraalVM 适用场景**

|**场景**|**适用原因**|
|---|---|
|**云计算 & 容器（Serverless）**|**AOT 编译，超快启动，低内存占用**|
|**高性能 Java 应用**|**比传统 JVM 运行更快**|
|**微服务（Spring Boot、Quarkus）**|**Native Image 编译，优化部署**|
|**多语言开发**|**支持 JS、Python、C/C++，无需额外解释器**|

---

## **6️⃣ GraalVM 如何提升 Java 应用性能？**

- **优化 JIT 编译**：GraalVM **比 HotSpot 默认 C2 编译器更快**。
- **AOT 编译**：将 Java 应用 **直接编译为原生二进制（无需 JVM 运行时）**，提高启动速度。
- **减少内存占用**：GraalVM **去除了 JVM 运行时的一些开销**，特别适用于 **云计算 & 容器**。

---

## **7️⃣ GraalVM 总结**

1. **GraalVM 是 Oracle 开发的高性能 Java 虚拟机，支持多语言执行**。
2. **提供 JIT + AOT 编译，提高 Java 应用启动速度 & 运行效率**。
3. **支持 Native Image（无 JVM 运行时），适用于 Serverless & 容器环境**。
4. **兼容 Java 生态（Spring Boot、Quarkus、Micronaut）**，适用于现代微服务架构。

# 53. ArrayList vs LinkedList：海量数据写入 & 删除的选择

在 Java 处理**海量数据的写入 & 删除**时，`ArrayList` 和 `LinkedList` 具有不同的特性，适用于不同的场景。

---

## **1️⃣ ArrayList vs LinkedList 数据结构**

|**列表类型**|**底层数据结构**|**插入 & 删除**|**查询**|
|---|---|---|---|
|**ArrayList**|**动态数组**（`Object[]`）|**慢**（需要数据移动）|**快**（O(1) 随机访问）|
|**LinkedList**|**双向链表**（`Node` 结构）|**快**（仅修改指针）|**慢**（O(n) 遍历访问）|

---

## **2️⃣ 海量写入（Insert）**

|**操作**|**ArrayList**|**LinkedList**|
|---|---|---|
|**尾部插入（append）**|**O(1)**（扩容时 O(n)）✅|**O(1)** ✅|
|**中间插入**|**O(n)** ❌（需要数据移动）|**O(n)** ❌（需要遍历）|
|**链表插入（前插/后插）**|**O(n)**（遍历 + 移动）❌|**O(1)** ✅（修改指针）|

**结论**：

- **尾部插入：两者性能相当（LinkedList 更稳定）**。
- **中间 & 任意位置插入：LinkedList 优势明显（O(1) 修改指针）**。

✅ **海量数据插入适合 `LinkedList`，尤其是插入频繁 & 不在尾部的情况**。

---

## **3️⃣ 海量删除（Delete）**

|**操作**|**ArrayList**|**LinkedList**|
|---|---|---|
|**尾部删除**|**O(1)** ✅（减少 size）|**O(1)** ✅|
|**中间删除**|**O(n)** ❌（需要移动元素）|**O(n)** ❌（需要遍历）|
|**头部删除**|**O(n)** ❌（所有元素前移）|**O(1)** ✅（修改指针）|

**结论**：

- **头部删除：LinkedList 更快**（O(1)）。
- **尾部删除：两者性能相当**。
- **中间删除：两者都需要遍历，LinkedList 修改指针比 ArrayList 数据移动稍快**。

✅ **海量数据删除适合 `LinkedList`，特别是头部 & 中间删除频繁的情况**。

---

## **4️⃣ 适用场景总结**

|**场景**|**推荐使用**|**原因**|
|---|---|---|
|**海量数据批量写入（插入大量数据）**|**`LinkedList`** ✅|**修改指针，无需移动数据**|
|**随机访问（频繁 `get(i)`）**|**`ArrayList`** ✅|**O(1) 直接索引访问**|
|**大数据量插入（特别是头部/中间）**|**`LinkedList`** ✅|**O(1) 修改指针**|
|**大数据量删除**|**`LinkedList`** ✅|**O(1) 删除节点，避免数据移动**|

---

## **5️⃣ 结论**

- **海量数据插入 & 删除（尤其是头部/中间）适合 `LinkedList`（O(1) 修改指针）**。
- **如果主要是随机访问（查询多），适合 `ArrayList`（O(1) 索引访问）**。
- **如果数据量大，且主要是顺序插入/删除（尾部操作），两者性能接近**。

# 54. 线程安全的 HashMap 实现方式

在 Java 中，`HashMap` **不是线程安全的**，如果多个线程并发访问 `HashMap` 可能会导致 **数据不一致、死循环、丢失数据** 等问题。因此，需要使用 **线程安全的 Map 实现**。

---

## **1️⃣ 线程安全的 `HashMap` 替代方案**

|**线程安全 Map**|**实现方式**|**适用场景**|
|---|---|---|
|**`Collections.synchronizedMap()`**|**同步封装 `HashMap`，使用 `synchronized`**|**简单封装，适合低并发场景**|
|**`ConcurrentHashMap`（推荐）**|**分段锁 + CAS**，高效并发支持|**高并发读写（如缓存、统计）**|
|**`ConcurrentSkipListMap`**|**基于跳表（SortedMap）**|**并发排序场景（如消息队列）**|
|**`Hashtable`（不推荐）**|**所有操作加 `synchronized`**|**性能较差，基本被淘汰**|

---

## **2️⃣ 线程安全 Map 详解**

### **📌 1. `Collections.synchronizedMap()`**

- 通过 `Collections.synchronizedMap(new HashMap<>())` **包装 `HashMap`**，所有方法使用 **`synchronized` 加锁**。
- **优点**：简单易用，适用于 **低并发**。
- **缺点**：**全局锁，多个线程访问时性能低**。

---

### **📌 2. `ConcurrentHashMap`（推荐）**

- **基于 CAS + 分段锁（JDK 1.7）或红黑树 + CAS（JDK 1.8）**，提供高效的并发支持。
- **高并发场景首选（读写分离 + 线程安全）**，适用于 **缓存、统计、频繁写入的场景**。

---

### **📌 3. `ConcurrentSkipListMap`**

- **基于跳表（Skip List）**，提供 **并发排序** 功能。
- **适用于** 需要 **排序的高并发场景**，如 **消息队列、定时任务调度**。

---

### **📌 4. `Hashtable`（已淘汰，不推荐）**

- **所有方法使用 `synchronized` 加锁**，单线程环境安全，但 **性能差**。
- **ConcurrentHashMap 替代 Hashtable**，几乎没有使用场景。

---

## **3️⃣ 适用场景总结**

|**场景**|**推荐 Map**|**原因**|
|---|---|---|
|**低并发（< 10 线程）**|`Collections.synchronizedMap()`|**简单封装 `HashMap`**|
|**高并发读写**|`ConcurrentHashMap` ✅|**无锁 / 低锁，性能优**|
|**有序存储（高并发排序）**|`ConcurrentSkipListMap` ✅|**跳表，自动排序**|
|**单线程（不涉及并发）**|`HashMap`|**无锁，最快**|

---

## **4️⃣ 结论**

- **并发环境推荐 `ConcurrentHashMap`（高性能，无全局锁）**。
- **低并发环境可使用 `Collections.synchronizedMap()`**。
- **有序存储（排序场景）推荐 `ConcurrentSkipListMap`**。
- **Hashtable 不再推荐，几乎被淘汰**。

# 55. CHW（Consistent Hashing with Virtual Nodes）实现原理

CHW（Consistent Hashing with Virtual Nodes）是 **基于一致性哈希（Consistent Hashing）** 的改进算法，**引入“虚拟节点（Virtual Nodes）”**，**优化数据分布，提升负载均衡性**。

---

## **1️⃣ CHW（一致性哈希 + 虚拟节点）的核心目标**

- 解决**数据分布不均（数据倾斜）**问题。
- 通过 **虚拟节点** 让数据在服务器之间 **更均匀地分布**。
- **减少服务器扩容/缩容时的数据迁移量**，提高稳定性。

---

## **2️⃣ 传统一致性哈希（Consistent Hashing）**

**一致性哈希（Consistent Hashing）** 采用**哈希环（Hash Ring）** 结构：

1. **将服务器（节点）哈希到 0~2³² 的环上**。
2. **数据通过哈希映射到最近的服务器节点**。

**问题：数据倾斜**

- 如果 **服务器节点数量较少**，部分服务器可能承担**大量数据**，导致负载不均衡。

---

## **3️⃣ CHW（一致性哈希 + 虚拟节点）如何优化？**

### **📌 1. 引入“虚拟节点”（Virtual Nodes）**

- **每个物理服务器对应多个虚拟节点（VNode）**，均匀分布在哈希环上。
- **数据映射到最近的虚拟节点，再映射到实际服务器**。

**优势**

- **数据更均匀分布**（避免热点服务器）。
- **减少服务器增减带来的数据迁移**（仅影响部分虚拟节点）。
- **提升负载均衡能力**。

---

### **📌 2. CHW（一致性哈希 + 虚拟节点）实现流程**

1. **计算服务器节点的哈希值**，映射到哈希环上。
2. **为每个服务器生成多个虚拟节点**，映射到哈希环上。
3. **计算数据的哈希值，映射到哈希环上**。
4. **顺时针查找最近的虚拟节点，找到对应的物理服务器**。

---

## **4️⃣ CHW vs 传统一致性哈希**

|**对比项**|**一致性哈希（CH）**|**一致性哈希 + 虚拟节点（CHW）**|
|---|---|---|
|**负载均衡**|**容易数据倾斜**|**数据分布均匀**|
|**服务器扩容/缩容**|**影响较大（大量数据迁移）**|**影响较小（只迁移部分虚拟节点）**|
|**实现复杂度**|**较低**|**较高**（需要额外维护虚拟节点）|
|**适用场景**|**小规模分布式系统**|**大规模分布式存储 & 负载均衡**|

---

## **5️⃣ CHW 适用场景**

|**场景**|**适用原因**|
|---|---|
|**分布式缓存（Redis Cluster、Memcached）**|**避免缓存热点，提高均衡性**|
|**分布式存储（HDFS、Ceph、Cassandra）**|**优化数据分布，减少扩容迁移**|
|**负载均衡（Nginx、Consistent Hashing）**|**均匀分配流量，防止服务器压力不均**|

---

## **6️⃣ 结论**

1. **CHW 通过“虚拟节点”优化一致性哈希，使数据均匀分布**，解决数据倾斜问题。
2. **相比传统一致性哈希，CHW 适用于大规模分布式存储 & 负载均衡**。
3. **扩容/缩容时，CHW 仅影响部分虚拟节点，减少数据迁移，提高可用性**。